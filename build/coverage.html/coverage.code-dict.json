{"/home/travis/build/npmtest/node-npmtest-js-csp/test.js":"/* istanbul instrument in package npmtest_js_csp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-js-csp/lib.npmtest_js_csp.js":"/* istanbul instrument in package npmtest_js_csp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_js_csp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_js_csp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-js-csp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-js-csp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_js_csp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_js_csp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_js_csp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_js_csp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_js_csp.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_js_csp.__dirname + '/lib.npmtest_js_csp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/csp.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.promiseChan = exports.chan = exports.go = exports.spawn = exports.NO_VALUE = exports.takeAsync = exports.putAsync = exports.alts = exports.sleep = exports.poll = exports.offer = exports.take = exports.put = exports.DEFAULT = exports.timeout = exports.CLOSED = exports.buffers = exports.operations = undefined;\n\nvar _channels = require('./impl/channels');\n\nObject.defineProperty(exports, 'CLOSED', {\n  enumerable: true,\n  get: function get() {\n    return _channels.CLOSED;\n  }\n});\n\nvar _timers = require('./impl/timers');\n\nObject.defineProperty(exports, 'timeout', {\n  enumerable: true,\n  get: function get() {\n    return _timers.timeout;\n  }\n});\n\nvar _results = require('./impl/results');\n\nObject.defineProperty(exports, 'DEFAULT', {\n  enumerable: true,\n  get: function get() {\n    return _results.DEFAULT;\n  }\n});\n\nvar _process = require('./impl/process');\n\nObject.defineProperty(exports, 'put', {\n  enumerable: true,\n  get: function get() {\n    return _process.put;\n  }\n});\nObject.defineProperty(exports, 'take', {\n  enumerable: true,\n  get: function get() {\n    return _process.take;\n  }\n});\nObject.defineProperty(exports, 'offer', {\n  enumerable: true,\n  get: function get() {\n    return _process.offer;\n  }\n});\nObject.defineProperty(exports, 'poll', {\n  enumerable: true,\n  get: function get() {\n    return _process.poll;\n  }\n});\nObject.defineProperty(exports, 'sleep', {\n  enumerable: true,\n  get: function get() {\n    return _process.sleep;\n  }\n});\nObject.defineProperty(exports, 'alts', {\n  enumerable: true,\n  get: function get() {\n    return _process.alts;\n  }\n});\nObject.defineProperty(exports, 'putAsync', {\n  enumerable: true,\n  get: function get() {\n    return _process.putThenCallback;\n  }\n});\nObject.defineProperty(exports, 'takeAsync', {\n  enumerable: true,\n  get: function get() {\n    return _process.takeThenCallback;\n  }\n});\nObject.defineProperty(exports, 'NO_VALUE', {\n  enumerable: true,\n  get: function get() {\n    return _process.NO_VALUE;\n  }\n});\n\nvar _csp = require('./csp.core');\n\nObject.defineProperty(exports, 'spawn', {\n  enumerable: true,\n  get: function get() {\n    return _csp.spawn;\n  }\n});\nObject.defineProperty(exports, 'go', {\n  enumerable: true,\n  get: function get() {\n    return _csp.go;\n  }\n});\nObject.defineProperty(exports, 'chan', {\n  enumerable: true,\n  get: function get() {\n    return _csp.chan;\n  }\n});\nObject.defineProperty(exports, 'promiseChan', {\n  enumerable: true,\n  get: function get() {\n    return _csp.promiseChan;\n  }\n});\n\nvar _buffers = require('./impl/buffers');\n\nvar _csp2 = require('./csp.operations');\n\nvar operations = exports.operations = {\n  mapFrom: _csp2.mapFrom,\n  mapInto: _csp2.mapInto,\n  filterFrom: _csp2.filterFrom,\n  filterInto: _csp2.filterInto,\n  removeFrom: _csp2.removeFrom,\n  removeInto: _csp2.removeInto,\n  mapcatFrom: _csp2.mapcatFrom,\n  mapcatInto: _csp2.mapcatInto,\n  pipe: _csp2.pipe,\n  split: _csp2.split,\n  reduce: _csp2.reduce,\n  onto: _csp2.onto,\n  fromColl: _csp2.fromColl,\n  map: _csp2.map,\n  merge: _csp2.merge,\n  into: _csp2.into,\n  unique: _csp2.unique,\n  partitionBy: _csp2.partitionBy,\n  partition: _csp2.partition,\n  mult: _csp2.mult,\n  mix: _csp2.mix,\n  pub: _csp2.pub,\n  pipeline: _csp2.pipeline,\n  pipelineAsync: _csp2.pipelineAsync,\n  take: _csp2.take\n};\nvar buffers = exports.buffers = { fixed: _buffers.fixed, dropping: _buffers.dropping, sliding: _buffers.sliding, promise: _buffers.promise };","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/channels.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Channel = exports.CLOSED = exports.MAX_QUEUE_SIZE = exports.MAX_DIRTY = undefined;\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nexports.chan = chan;\n\nvar _buffers = require('./buffers');\n\nvar _boxes = require('./boxes');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar MAX_DIRTY = exports.MAX_DIRTY = 64;\nvar MAX_QUEUE_SIZE = exports.MAX_QUEUE_SIZE = 1024;\nvar CLOSED = exports.CLOSED = null;\n\nvar Channel = exports.Channel = function () {\n  function Channel(takes, puts, buf, xform) {\n    (0, _classCallCheck3.default)(this, Channel);\n\n    this.buf = buf;\n    this.xform = xform;\n    this.takes = takes;\n    this.puts = puts;\n    this.dirtyTakes = 0;\n    this.dirtyPuts = 0;\n    this.closed = false;\n  }\n\n  (0, _createClass3.default)(Channel, [{\n    key: 'put',\n    value: function put(value, handler) {\n      if (value === CLOSED) {\n        throw new Error('Cannot put CLOSED on a channel.');\n      }\n\n      // TODO: I'm not sure how this can happen, because the operations\n      // are registered in 1 tick, and the only way for this to be inactive\n      // is for a previous operation in the same alt to have returned\n      // immediately, which would have short-circuited to prevent this to\n      // be ever register anyway. The same thing goes for the active check\n      // in \"take\".\n      if (!handler.isActive()) {\n        return null;\n      }\n\n      if (this.closed) {\n        handler.commit();\n        return new _boxes.Box(false);\n      }\n\n      // Soak the value through the buffer first, even if there is a\n      // pending taker. This way the step function has a chance to act on the\n      // value.\n      if (this.buf && !this.buf.isFull()) {\n        handler.commit();\n        var done = (0, _utils.isReduced)(this.xform['@@transducer/step'](this.buf, value));\n\n        // flow-ignore\n        while (this.buf.count() > 0 && this.takes.length > 0) {\n          var taker = this.takes.pop();\n\n          // flow-ignore\n          if (taker.isActive()) {\n            // flow-ignore\n            (0, _utils.taskScheduler)(taker.commit(), this.buf.remove());\n          }\n        }\n\n        if (done) {\n          this.close();\n        }\n        return new _boxes.Box(true);\n      }\n\n      // Either the buffer is full, in which case there won't be any\n      // pending takes, or we don't have a buffer, in which case this loop\n      // fulfills the first of them that is active (note that we don't\n      // have to worry about transducers here since we require a buffer\n      // for that).\n      while (this.takes.length > 0) {\n        var _taker = this.takes.pop();\n\n        // flow-ignore\n        if (_taker.isActive()) {\n          handler.commit();\n          // flow-ignore\n          (0, _utils.taskScheduler)(_taker.commit(), value);\n          return new _boxes.Box(true);\n        }\n      }\n\n      // No buffer, full buffer, no pending takes. Queue this put now if blockable.\n      if (this.dirtyPuts > MAX_DIRTY) {\n        this.puts.cleanup(function (putter) {\n          return putter.handler.isActive();\n        });\n        this.dirtyPuts = 0;\n      } else {\n        this.dirtyPuts += 1;\n      }\n\n      if (handler.isBlockable()) {\n        if (this.puts.length >= MAX_QUEUE_SIZE) {\n          throw new Error('No more than ' + MAX_QUEUE_SIZE + ' pending puts are allowed on a single channel.');\n        }\n        this.puts.unboundedUnshift(new _boxes.PutBox(handler, value));\n      }\n\n      return null;\n    }\n  }, {\n    key: 'take',\n    value: function take(handler) {\n      if (!handler.isActive()) {\n        return null;\n      }\n\n      if (this.buf && this.buf.count() > 0) {\n        handler.commit();\n        // flow-ignore\n        var value = this.buf.remove();\n\n        // We need to check pending puts here, other wise they won't\n        // be able to proceed until their number reaches MAX_DIRTY\n\n        // flow-ignore\n        while (this.puts.length > 0 && !this.buf.isFull()) {\n          var putter = this.puts.pop();\n\n          // flow-ignore\n          if (putter.handler.isActive()) {\n            // flow-ignore\n            (0, _utils.taskScheduler)(putter.handler.commit(), true);\n\n            // flow-ignore\n            if ((0, _utils.isReduced)(this.xform['@@transducer/step'](this.buf, putter.value))) {\n              this.close();\n            }\n          }\n        }\n        return new _boxes.Box(value);\n      }\n\n      // Either the buffer is empty, in which case there won't be any\n      // pending puts, or we don't have a buffer, in which case this loop\n      // fulfills the first of them that is active (note that we don't\n      // have to worry about transducers here since we require a buffer\n      // for that).\n      while (this.puts.length > 0) {\n        var _putter = this.puts.pop();\n\n        // flow-ignore\n        if (_putter.handler.isActive()) {\n          handler.commit();\n          // flow-ignore\n          (0, _utils.taskScheduler)(_putter.handler.commit(), true);\n\n          // flow-ignore\n          return new _boxes.Box(_putter.value);\n        }\n      }\n\n      if (this.closed) {\n        handler.commit();\n        return new _boxes.Box(CLOSED);\n      }\n\n      // No buffer, empty buffer, no pending puts. Queue this take now if blockable.\n      if (this.dirtyTakes > MAX_DIRTY) {\n        this.takes.cleanup(function (_handler) {\n          return _handler.isActive();\n        });\n        this.dirtyTakes = 0;\n      } else {\n        this.dirtyTakes += 1;\n      }\n\n      if (handler.isBlockable()) {\n        if (this.takes.length >= MAX_QUEUE_SIZE) {\n          throw new Error('No more than ' + MAX_QUEUE_SIZE + ' pending takes are allowed on a single channel.');\n        }\n\n        this.takes.unboundedUnshift(handler);\n      }\n\n      return null;\n    }\n  }, {\n    key: 'close',\n    value: function close() {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n\n      if (this.buf) {\n        this.xform['@@transducer/result'](this.buf);\n\n        while (this.buf.count() > 0 && this.takes.length > 0) {\n          var taker = this.takes.pop();\n\n          // flow-ignore\n          if (taker.isActive()) {\n            // flow-ignore\n            (0, _utils.taskScheduler)(taker.commit(), this.buf.remove());\n          }\n        }\n      }\n\n      (0, _utils.flush)(this.takes, function (taker) {\n        if (taker.isActive()) {\n          (0, _utils.taskScheduler)(taker.commit(), CLOSED);\n        }\n      });\n\n      (0, _utils.flush)(this.puts, function (putter) {\n        if (putter.handler.isActive()) {\n          (0, _utils.taskScheduler)(putter.handler.commit(), false);\n        }\n      });\n    }\n  }, {\n    key: 'isClosed',\n    value: function isClosed() {\n      return this.closed;\n    }\n  }]);\n  return Channel;\n}();\n\n// The base transformer object to use with transducers\n\n\nvar AddTransformer = {\n  '@@transducer/init': function transducerInit() {\n    throw new Error('init not available');\n  },\n\n  '@@transducer/result': function transducerResult(v) {\n    return v;\n  },\n\n  '@@transducer/step': function transducerStep(buffer, input) {\n    buffer.add(input);\n    return buffer;\n  }\n};\n\nfunction defaultExceptionHandler(err) {\n  console.log('error in channel transformer', err.stack); // eslint-disable-line\n  return CLOSED;\n}\n\nfunction handleEx(buf, exHandler, e) {\n  var def = (exHandler || defaultExceptionHandler)(e);\n\n  if (def !== CLOSED) {\n    buf.add(def);\n  }\n\n  return buf;\n}\n\nfunction handleException(exHandler) {\n  return function (xform) {\n    return {\n      '@@transducer/step': function transducerStep(buffer, input) {\n        try {\n          return xform['@@transducer/step'](buffer, input);\n        } catch (e) {\n          return handleEx(buffer, exHandler, e);\n        }\n      },\n      '@@transducer/result': function transducerResult(buffer) {\n        try {\n          return xform['@@transducer/result'](buffer);\n        } catch (e) {\n          return handleEx(buffer, exHandler, e);\n        }\n      }\n    };\n  };\n}\n\n// XXX: This is inconsistent. We should either call the reducing\n// function xform, or call the transducers xform, not both\nfunction chan(buf, xform, exHandler) {\n  var newXForm = void 0;\n\n  if (xform) {\n    if (!buf) {\n      throw new Error('Only buffered channels can use transducers');\n    }\n\n    newXForm = xform(AddTransformer);\n  } else {\n    newXForm = AddTransformer;\n  }\n\n  return new Channel((0, _buffers.ring)(32), (0, _buffers.ring)(32), buf, handleException(exHandler)(newXForm));\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/buffers.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PromiseBuffer = exports.SlidingBuffer = exports.DroppingBuffer = exports.FixedBuffer = exports.RingBuffer = undefined;\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nexports.ring = ring;\nexports.fixed = fixed;\nexports.dropping = dropping;\nexports.sliding = sliding;\nexports.promise = promise;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction acopy(src, srcStart, dest, destStart, len) {\n  for (var count = 0; count < len; count += 1) {\n    dest[destStart + count] = src[srcStart + count];\n  }\n}\n\nvar RingBuffer = exports.RingBuffer = function () {\n  function RingBuffer(head, tail, length, arr) {\n    (0, _classCallCheck3.default)(this, RingBuffer);\n\n    this.head = head;\n    this.tail = tail;\n    this.length = length;\n    this.arr = arr;\n  }\n\n  (0, _createClass3.default)(RingBuffer, [{\n    key: \"pop\",\n    value: function pop() {\n      if (this.length !== 0) {\n        var elem = this.arr[this.tail];\n\n        this.arr[this.tail] = undefined;\n        this.tail = (this.tail + 1) % this.arr.length;\n        this.length -= 1;\n\n        return elem;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(element) {\n      this.arr[this.head] = element;\n      this.head = (this.head + 1) % this.arr.length;\n      this.length += 1;\n    }\n  }, {\n    key: \"unboundedUnshift\",\n    value: function unboundedUnshift(element) {\n      if (this.length + 1 === this.arr.length) {\n        this.resize();\n      }\n      this.unshift(element);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var newArrSize = this.arr.length * 2;\n      var newArr = new Array(newArrSize);\n\n      if (this.tail < this.head) {\n        acopy(this.arr, this.tail, newArr, 0, this.length);\n        this.tail = 0;\n        this.head = this.length;\n        this.arr = newArr;\n      } else if (this.tail > this.head) {\n        acopy(this.arr, this.tail, newArr, 0, this.arr.length - this.tail);\n        acopy(this.arr, 0, newArr, this.arr.length - this.tail, this.head);\n        this.tail = 0;\n        this.head = this.length;\n        this.arr = newArr;\n      } else if (this.tail === this.head) {\n        this.tail = 0;\n        this.head = 0;\n        this.arr = newArr;\n      }\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup(predicate) {\n      for (var i = this.length; i > 0; i -= 1) {\n        var value = this.pop();\n\n        if (predicate(value)) {\n          this.unshift(value);\n        }\n      }\n    }\n  }]);\n  return RingBuffer;\n}();\n\nfunction ring(n) {\n  if (n <= 0) {\n    throw new Error(\"Can't create a ring buffer of size 0\");\n  }\n\n  return new RingBuffer(0, 0, 0, new Array(n));\n}\n\n/**\n * Returns a buffer that is considered \"full\" when it reaches size n,\n * but still accepts additional items, effectively allow overflowing.\n * The overflowing behavior is useful for supporting \"expanding\"\n * transducers, where we want to check if a buffer is full before\n * running the transduced step function, while still allowing a\n * transduced step to expand into multiple \"essence\" steps.\n */\n\nvar FixedBuffer = exports.FixedBuffer = function () {\n  function FixedBuffer(buffer, n) {\n    (0, _classCallCheck3.default)(this, FixedBuffer);\n\n    this.buffer = buffer;\n    this.n = n;\n  }\n\n  (0, _createClass3.default)(FixedBuffer, [{\n    key: \"isFull\",\n    value: function isFull() {\n      return this.buffer.length === this.n;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      return this.buffer.pop();\n    }\n  }, {\n    key: \"add\",\n    value: function add(item) {\n      this.buffer.unboundedUnshift(item);\n    }\n  }, {\n    key: \"closeBuffer\",\n    value: function closeBuffer() {} // eslint-disable-line\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.buffer.length;\n    }\n  }]);\n  return FixedBuffer;\n}();\n\nfunction fixed(n) {\n  return new FixedBuffer(ring(n), n);\n}\n\nvar DroppingBuffer = exports.DroppingBuffer = function () {\n  function DroppingBuffer(buffer, n) {\n    (0, _classCallCheck3.default)(this, DroppingBuffer);\n\n    this.buffer = buffer;\n    this.n = n;\n  }\n\n  (0, _createClass3.default)(DroppingBuffer, [{\n    key: \"isFull\",\n    value: function isFull() {\n      // eslint-disable-line\n      return false;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      return this.buffer.pop();\n    }\n  }, {\n    key: \"add\",\n    value: function add(item) {\n      if (this.buffer.length !== this.n) {\n        this.buffer.unshift(item);\n      }\n    }\n  }, {\n    key: \"closeBuffer\",\n    value: function closeBuffer() {} // eslint-disable-line\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.buffer.length;\n    }\n  }]);\n  return DroppingBuffer;\n}();\n\nfunction dropping(n) {\n  return new DroppingBuffer(ring(n), n);\n}\n\nvar SlidingBuffer = exports.SlidingBuffer = function () {\n  function SlidingBuffer(buffer, n) {\n    (0, _classCallCheck3.default)(this, SlidingBuffer);\n\n    this.buffer = buffer;\n    this.n = n;\n  }\n\n  (0, _createClass3.default)(SlidingBuffer, [{\n    key: \"isFull\",\n    value: function isFull() {\n      // eslint-disable-line\n      return false;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      return this.buffer.pop();\n    }\n  }, {\n    key: \"add\",\n    value: function add(item) {\n      if (this.buffer.length === this.n) {\n        this.remove();\n      }\n\n      this.buffer.unshift(item);\n    }\n  }, {\n    key: \"closeBuffer\",\n    value: function closeBuffer() {} // eslint-disable-line\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.buffer.length;\n    }\n  }]);\n  return SlidingBuffer;\n}();\n\nfunction sliding(n) {\n  return new SlidingBuffer(ring(n), n);\n}\n\nvar PromiseBuffer = exports.PromiseBuffer = function () {\n  function PromiseBuffer(value) {\n    (0, _classCallCheck3.default)(this, PromiseBuffer);\n\n    this.value = value;\n  }\n\n  (0, _createClass3.default)(PromiseBuffer, [{\n    key: \"isFull\",\n    value: function isFull() {\n      // eslint-disable-line\n      return false;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      return this.value;\n    }\n  }, {\n    key: \"add\",\n    value: function add(item) {\n      if (PromiseBuffer.isUndelivered(this.value)) {\n        this.value = item;\n      }\n    }\n  }, {\n    key: \"closeBuffer\",\n    value: function closeBuffer() {\n      if (PromiseBuffer.isUndelivered(this.value)) {\n        this.value = null;\n      }\n    }\n  }, {\n    key: \"count\",\n    value: function count() {\n      return PromiseBuffer.isUndelivered(this.value) ? 0 : 1;\n    }\n  }]);\n  return PromiseBuffer;\n}();\n\nPromiseBuffer.NO_VALUE = '@@PromiseBuffer/NO_VALUE';\n\nPromiseBuffer.isUndelivered = function (value) {\n  return PromiseBuffer.NO_VALUE === value;\n};\n\nfunction promise() {\n  return new PromiseBuffer(PromiseBuffer.NO_VALUE);\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/boxes.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PutBox = exports.Box = undefined;\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Box = exports.Box = function Box(value) {\n  (0, _classCallCheck3.default)(this, Box);\n\n  this.value = value;\n};\n\nvar PutBox = exports.PutBox = function PutBox(handler, value) {\n  (0, _classCallCheck3.default)(this, PutBox);\n\n  this.handler = handler;\n  this.value = value;\n};","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/utils.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isReduced = exports.taskScheduler = undefined;\nexports.flush = flush;\n\nvar _dispatch = require('./dispatch');\n\nvar taskScheduler = exports.taskScheduler = function taskScheduler(func, value) {\n  (0, _dispatch.run)(function () {\n    return func(value);\n  });\n};\nvar isReduced = exports.isReduced = function isReduced(v) {\n  return v && v['@@transducer/reduced'];\n};\n\nfunction flush(channelBuffer, callback) {\n  while (channelBuffer.length > 0) {\n    callback(channelBuffer.pop());\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/dispatch.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _setImmediate2 = require('babel-runtime/core-js/set-immediate');\n\nvar _setImmediate3 = _interopRequireDefault(_setImmediate2);\n\nexports.queueDispatcher = queueDispatcher;\nexports.run = run;\nexports.queueDelay = queueDelay;\n\nvar _buffers = require('./buffers');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar TASK_BATCH_SIZE = 1024;\n\nvar tasks = (0, _buffers.ring)(32);\nvar running = false;\nvar queued = false;\n\nfunction queueDispatcher() {\n  // See the implementation of setImmediate at babel-runtime/core-js/set-immediate\n  // https://github.com/zloirock/core-js/blob/e482646353b489e200a5ecccca6af5c01f0b4ef2/library/modules/_task.js\n  // Under the hood, it will use process.nextTick, MessageChannel, and fallback to setTimeout\n  if (!(queued && running)) {\n    queued = true;\n\n    (0, _setImmediate3.default)(function () {\n      var count = 0;\n\n      running = true;\n      queued = false;\n\n      while (count < TASK_BATCH_SIZE) {\n        var task = tasks.pop();\n\n        if (task) {\n          task();\n          count += 1;\n        } else {\n          break;\n        }\n      }\n\n      running = false;\n\n      if (tasks.length > 0) {\n        queueDispatcher();\n      }\n    });\n  }\n}\n\nfunction run(func) {\n  tasks.unboundedUnshift(func);\n  queueDispatcher();\n}\n\nfunction queueDelay(func, delay) {\n  setTimeout(func, delay);\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/timers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.timeout = timeout;\n\nvar _dispatch = require('./dispatch');\n\nvar _channels = require('./channels');\n\nfunction timeout(msecs) {\n  // eslint-disable-line\n  var ch = (0, _channels.chan)();\n\n  (0, _dispatch.queueDelay)(function () {\n    return ch.close();\n  }, msecs);\n\n  return ch;\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/results.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AltResult = exports.DEFAULT = undefined;\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _channels = require('./channels');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar DEFAULT = exports.DEFAULT = {\n  toString: function toString() {\n    return '[object DEFAULT]';\n  }\n};\n\nvar AltResult = exports.AltResult = function AltResult(value, channel) {\n  (0, _classCallCheck3.default)(this, AltResult);\n\n  this.value = value;\n  this.channel = channel;\n};","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/process.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Process = exports.NO_VALUE = undefined;\n\nvar _setImmediate2 = require('babel-runtime/core-js/set-immediate');\n\nvar _setImmediate3 = _interopRequireDefault(_setImmediate2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nexports.putThenCallback = putThenCallback;\nexports.takeThenCallback = takeThenCallback;\nexports.take = take;\nexports.put = put;\nexports.sleep = sleep;\nexports.alts = alts;\nexports.poll = poll;\nexports.offer = offer;\n\nvar _select = require('./select');\n\nvar _handlers = require('./handlers');\n\nvar _instruction = require('./instruction');\n\nvar _boxes = require('./boxes');\n\nvar _channels = require('./channels');\n\nvar _dispatch = require('./dispatch');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NO_VALUE = exports.NO_VALUE = '@@process/NO_VALUE';\n\nfunction putThenCallback(channel, value, callback) {\n  var result = channel.put(value, new _handlers.FnHandler(true, callback));\n\n  if (result && callback) {\n    callback(result.value);\n  }\n}\n\nfunction takeThenCallback(channel, callback) {\n  var result = channel.take(new _handlers.FnHandler(true, callback));\n\n  if (result && callback) {\n    callback(result.value);\n  }\n}\n\nfunction take(channel) {\n  return new _instruction.TakeInstruction(channel);\n}\n\nfunction put(channel, value) {\n  return new _instruction.PutInstruction(channel, value);\n}\n\nfunction sleep(msecs) {\n  return new _instruction.SleepInstruction(msecs);\n}\n\nfunction alts(operations, options) {\n  return new _instruction.AltsInstruction(operations, options);\n}\n\nfunction poll(channel) {\n  if (channel.closed) {\n    return NO_VALUE;\n  }\n\n  var result = channel.take(new _handlers.FnHandler(false));\n\n  return result ? result.value : NO_VALUE;\n}\n\nfunction offer(channel, value) {\n  if (channel.closed) {\n    return false;\n  }\n\n  var result = channel.put(value, new _handlers.FnHandler(false));\n\n  return result instanceof _boxes.Box;\n}\n\nvar Process = exports.Process = function () {\n  function Process(gen, onFinishFunc) {\n    var _this = this;\n\n    (0, _classCallCheck3.default)(this, Process);\n\n    this.schedule = function (nextState) {\n      (0, _setImmediate3.default)(function () {\n        return _this.run(nextState);\n      });\n    };\n\n    this.gen = gen;\n    this.finished = false;\n    this.onFinishFunc = onFinishFunc;\n  }\n\n  (0, _createClass3.default)(Process, [{\n    key: 'run',\n    value: function run(state) {\n      if (!this.finished) {\n        // TODO: Shouldn't we (optionally) stop error propagation here (and\n        // signal the error through a channel or something)? Otherwise the\n        // uncaught exception will crash some runtimes (e.g. Node)\n        var _gen$next = this.gen.next(state),\n            done = _gen$next.done,\n            value = _gen$next.value;\n\n        if (done) {\n          this.finished = true;\n          this.onFinishFunc(value);\n        } else if (value instanceof _instruction.TakeInstruction) {\n          takeThenCallback(value.channel, this.schedule);\n        } else if (value instanceof _instruction.PutInstruction) {\n          putThenCallback(value.channel, value.value, this.schedule);\n        } else if (value instanceof _instruction.SleepInstruction) {\n          (0, _dispatch.queueDelay)(this.schedule, value.msec);\n        } else if (value instanceof _instruction.AltsInstruction) {\n          (0, _select.doAlts)(value.operations, this.schedule, value.options);\n        } else if (value instanceof _channels.Channel) {\n          takeThenCallback(value, this.schedule);\n        } else {\n          this.schedule(value);\n        }\n      }\n    }\n  }]);\n  return Process;\n}();","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/select.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doAlts = doAlts;\n\nvar _get = require('lodash/get');\n\nvar _get2 = _interopRequireDefault(_get);\n\nvar _range = require('lodash/range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _shuffle = require('lodash/shuffle');\n\nvar _shuffle2 = _interopRequireDefault(_shuffle);\n\nvar _boxes = require('./boxes');\n\nvar _channels = require('./channels');\n\nvar _handlers = require('./handlers');\n\nvar _results = require('./results');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// TODO: Accept a priority function or something\nfunction doAlts( // eslint-disable-line\noperations, callback, options) {\n  if (operations.length === 0) {\n    throw new Error('Empty alt list');\n  }\n\n  var flag = new _boxes.Box(true);\n  var indexes = (0, _shuffle2.default)((0, _range2.default)(operations.length));\n  var hasPriority = !!(options && options.priority);\n  var result = void 0;\n\n  var _loop = function _loop(i) {\n    var operation = operations[hasPriority ? i : indexes[i]];\n    var ch = void 0;\n\n    if (operation instanceof _channels.Channel) {\n      ch = operation;\n      result = ch.take(new _handlers.AltHandler(flag, function (value) {\n        return callback(new _results.AltResult(value, ch));\n      }));\n    } else {\n      ch = operation[0];\n      result = ch.put(operation[1], new _handlers.AltHandler(flag, function (value) {\n        return callback(new _results.AltResult(value, ch));\n      }));\n    }\n\n    if (result) {\n      callback(new _results.AltResult(result.value, ch));\n      return 'break';\n    }\n  };\n\n  for (var i = 0; i < operations.length; i += 1) {\n    var _ret = _loop(i);\n\n    if (_ret === 'break') break;\n  }\n\n  if (!result && (0, _get2.default)(options, 'default') && flag.value) {\n    flag.value = false;\n    callback(new _results.AltResult(options.default, _results.DEFAULT));\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/handlers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AltHandler = exports.FnHandler = undefined;\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _boxes = require('./boxes');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FnHandler = exports.FnHandler = function () {\n  function FnHandler(blockable, func) {\n    (0, _classCallCheck3.default)(this, FnHandler);\n\n    this.blockable = blockable;\n    this.func = func || _noop2.default;\n  }\n\n  (0, _createClass3.default)(FnHandler, [{\n    key: 'isActive',\n    value: function isActive() {\n      // eslint-disable-line\n      return true;\n    }\n  }, {\n    key: 'isBlockable',\n    value: function isBlockable() {\n      return this.blockable;\n    }\n  }, {\n    key: 'commit',\n    value: function commit() {\n      return this.func;\n    }\n  }]);\n  return FnHandler;\n}();\n\nvar AltHandler = exports.AltHandler = function () {\n  function AltHandler(flag, func) {\n    (0, _classCallCheck3.default)(this, AltHandler);\n\n    this.flag = flag;\n    this.func = func;\n  }\n\n  (0, _createClass3.default)(AltHandler, [{\n    key: 'isActive',\n    value: function isActive() {\n      return this.flag.value;\n    }\n  }, {\n    key: 'isBlockable',\n    value: function isBlockable() {\n      // eslint-disable-line\n      return true;\n    }\n  }, {\n    key: 'commit',\n    value: function commit() {\n      this.flag.value = false;\n      return this.func;\n    }\n  }]);\n  return AltHandler;\n}();","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/impl/instruction.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AltsInstruction = exports.SleepInstruction = exports.PutInstruction = exports.TakeInstruction = undefined;\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _channels = require('./channels');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar TakeInstruction = exports.TakeInstruction = function TakeInstruction(channel) {\n  (0, _classCallCheck3.default)(this, TakeInstruction);\n\n  this.channel = channel;\n};\n\nvar PutInstruction = exports.PutInstruction = function PutInstruction(channel, value) {\n  (0, _classCallCheck3.default)(this, PutInstruction);\n\n  this.channel = channel;\n  this.value = value;\n};\n\nvar SleepInstruction = exports.SleepInstruction = function SleepInstruction(msec) {\n  (0, _classCallCheck3.default)(this, SleepInstruction);\n\n  this.msec = msec;\n};\n\nvar AltsInstruction = exports.AltsInstruction = function AltsInstruction(operations, options) {\n  (0, _classCallCheck3.default)(this, AltsInstruction);\n\n  this.operations = operations;\n  this.options = options;\n};","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/csp.core.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nexports.spawn = spawn;\nexports.go = go;\nexports.chan = chan;\nexports.promiseChan = promiseChan;\n\nvar _buffers = require('./impl/buffers');\n\nvar _process = require('./impl/process');\n\nvar _channels = require('./impl/channels');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction spawn(gen) {\n  var ch = (0, _channels.chan)((0, _buffers.fixed)(1));\n  var process = new _process.Process(gen, function (value) {\n    if (value === _channels.CLOSED) {\n      ch.close();\n    } else {\n      (0, _process.putThenCallback)(ch, value, function () {\n        return ch.close();\n      });\n    }\n  });\n\n  process.run();\n  return ch;\n}\n\nfunction go(f) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  return spawn(f.apply(undefined, (0, _toConsumableArray3.default)(args)));\n}\n\nfunction chan(bufferOrNumber, xform, exHandler) {\n  if (typeof bufferOrNumber === 'number') {\n    return (0, _channels.chan)(bufferOrNumber === 0 ? null : (0, _buffers.fixed)(bufferOrNumber), xform, exHandler);\n  }\n\n  return (0, _channels.chan)(bufferOrNumber, xform, exHandler);\n}\n\nfunction promiseChan(xform, exHandler) {\n  return (0, _channels.chan)((0, _buffers.promise)(), xform, exHandler);\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/lib/csp.operations.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nexports.mapFrom = mapFrom;\nexports.mapInto = mapInto;\nexports.filterFrom = filterFrom;\nexports.filterInto = filterInto;\nexports.removeFrom = removeFrom;\nexports.removeInto = removeInto;\nexports.mapcatFrom = mapcatFrom;\nexports.mapcatInto = mapcatInto;\nexports.pipe = pipe;\nexports.split = split;\nexports.reduce = reduce;\nexports.onto = onto;\nexports.fromColl = fromColl;\nexports.map = map;\nexports.merge = merge;\nexports.into = into;\nexports.take = take;\nexports.unique = unique;\nexports.partitionBy = partitionBy;\nexports.partition = partition;\nexports.mult = mult;\nexports.mix = mix;\nexports.pub = pub;\nexports.pipeline = pipeline;\nexports.pipelineAsync = pipelineAsync;\n\nvar _times = require('lodash/times');\n\nvar _times2 = _interopRequireDefault(_times);\n\nvar _boxes = require('./impl/boxes');\n\nvar _channels = require('./impl/channels');\n\nvar _process = require('./impl/process');\n\nvar _csp = require('./csp.core');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _marked = [mapcat].map(_regenerator2.default.mark);\n\nfunction mapFrom(f, ch) {\n  return {\n    isClosed: function isClosed() {\n      return ch.isClosed();\n    },\n    close: function close() {\n      ch.close();\n    },\n    put: function put(value, handler) {\n      return ch.put(value, handler);\n    },\n    take: function take(handler) {\n      var result = ch.take({\n        isActive: function isActive() {\n          return handler.isActive();\n        },\n        commit: function commit() {\n          var takeCallback = handler.commit();\n          return function (value) {\n            return takeCallback(value === _channels.CLOSED ? _channels.CLOSED : f(value));\n          };\n        }\n      });\n\n      if (result) {\n        var value = result.value;\n        return new _boxes.Box(value === _channels.CLOSED ? _channels.CLOSED : f(value));\n      }\n\n      return null;\n    }\n  };\n}\n\nfunction mapInto(f, ch) {\n  return {\n    isClosed: function isClosed() {\n      return ch.isClosed();\n    },\n    close: function close() {\n      ch.close();\n    },\n    put: function put(value, handler) {\n      return ch.put(f(value), handler);\n    },\n    take: function take(handler) {\n      return ch.take(handler);\n    }\n  };\n}\n\nfunction filterFrom(p, ch, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n\n  (0, _csp.go)(_regenerator2.default.mark(function _callee() {\n    var value;\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return (0, _process.take)(ch);\n\n          case 2:\n            value = _context.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context.next = 6;\n              break;\n            }\n\n            out.close();\n            return _context.abrupt('break', 11);\n\n          case 6:\n            if (!p(value)) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 9;\n            return (0, _process.put)(out, value);\n\n          case 9:\n            _context.next = 0;\n            break;\n\n          case 11:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  return out;\n}\n\nfunction filterInto(p, ch) {\n  return {\n    isClosed: function isClosed() {\n      return ch.isClosed();\n    },\n    close: function close() {\n      ch.close();\n    },\n    put: function put(value, handler) {\n      if (p(value)) {\n        return ch.put(value, handler);\n      }\n\n      return new _boxes.Box(!ch.isClosed());\n    },\n    take: function take(handler) {\n      return ch.take(handler);\n    }\n  };\n}\n\nfunction removeFrom(p, ch) {\n  return filterFrom(function (value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction removeInto(p, ch) {\n  return filterInto(function (value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction mapcat(f, src, dst) {\n  var value, seq, length, i;\n  return _regenerator2.default.wrap(function mapcat$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return (0, _process.take)(src);\n\n        case 2:\n          value = _context2.sent;\n\n          if (!(value === _channels.CLOSED)) {\n            _context2.next = 8;\n            break;\n          }\n\n          dst.close();\n          return _context2.abrupt('break', 21);\n\n        case 8:\n          seq = f(value);\n          length = seq.length;\n          i = 0;\n\n        case 11:\n          if (!(i < length)) {\n            _context2.next = 17;\n            break;\n          }\n\n          _context2.next = 14;\n          return (0, _process.put)(dst, seq[i]);\n\n        case 14:\n          i += 1;\n          _context2.next = 11;\n          break;\n\n        case 17:\n          if (!dst.isClosed()) {\n            _context2.next = 19;\n            break;\n          }\n\n          return _context2.abrupt('break', 21);\n\n        case 19:\n          _context2.next = 0;\n          break;\n\n        case 21:\n        case 'end':\n          return _context2.stop();\n      }\n    }\n  }, _marked[0], this);\n}\n\nfunction mapcatFrom(f, ch, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n  (0, _csp.go)(mapcat, [f, ch, out]);\n  return out;\n}\n\nfunction mapcatInto(f, ch, bufferOrN) {\n  var src = (0, _csp.chan)(bufferOrN);\n  (0, _csp.go)(mapcat, [f, src, ch]);\n  return src;\n}\n\nfunction pipe(src, dst, keepOpen) {\n  (0, _csp.go)(_regenerator2.default.mark(function _callee2() {\n    var value;\n    return _regenerator2.default.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return (0, _process.take)(src);\n\n          case 2:\n            value = _context3.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context3.next = 6;\n              break;\n            }\n\n            if (!keepOpen) {\n              dst.close();\n            }\n            return _context3.abrupt('break', 12);\n\n          case 6:\n            _context3.next = 8;\n            return (0, _process.put)(dst, value);\n\n          case 8:\n            if (_context3.sent) {\n              _context3.next = 10;\n              break;\n            }\n\n            return _context3.abrupt('break', 12);\n\n          case 10:\n            _context3.next = 0;\n            break;\n\n          case 12:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n  return dst;\n}\n\nfunction split(p, ch, trueBufferOrN, falseBufferOrN) {\n  var tch = (0, _csp.chan)(trueBufferOrN);\n  var fch = (0, _csp.chan)(falseBufferOrN);\n  (0, _csp.go)(_regenerator2.default.mark(function _callee3() {\n    var value;\n    return _regenerator2.default.wrap(function _callee3$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return (0, _process.take)(ch);\n\n          case 2:\n            value = _context4.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context4.next = 7;\n              break;\n            }\n\n            tch.close();\n            fch.close();\n            return _context4.abrupt('break', 11);\n\n          case 7:\n            _context4.next = 9;\n            return (0, _process.put)(p(value) ? tch : fch, value);\n\n          case 9:\n            _context4.next = 0;\n            break;\n\n          case 11:\n          case 'end':\n            return _context4.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n  return [tch, fch];\n}\n\nfunction reduce(f, init, ch) {\n  return (0, _csp.go)(_regenerator2.default.mark(function _callee4() {\n    var result, value;\n    return _regenerator2.default.wrap(function _callee4$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            result = init;\n\n          case 1:\n            _context5.next = 3;\n            return (0, _process.take)(ch);\n\n          case 3:\n            value = _context5.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context5.next = 6;\n              break;\n            }\n\n            return _context5.abrupt('return', result);\n\n          case 6:\n\n            result = f(result, value);\n\n          case 7:\n            _context5.next = 1;\n            break;\n\n          case 9:\n          case 'end':\n            return _context5.stop();\n        }\n      }\n    }, _callee4, this);\n  }), [], true);\n}\n\nfunction onto(ch, coll, keepOpen) {\n  return (0, _csp.go)(_regenerator2.default.mark(function _callee5() {\n    var length, i;\n    return _regenerator2.default.wrap(function _callee5$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            length = coll.length;\n            // FIX: Should be a generic looping interface (for...in?)\n\n            i = 0;\n\n          case 2:\n            if (!(i < length)) {\n              _context6.next = 8;\n              break;\n            }\n\n            _context6.next = 5;\n            return (0, _process.put)(ch, coll[i]);\n\n          case 5:\n            i += 1;\n            _context6.next = 2;\n            break;\n\n          case 8:\n            if (!keepOpen) {\n              ch.close();\n            }\n\n          case 9:\n          case 'end':\n            return _context6.stop();\n        }\n      }\n    }, _callee5, this);\n  }));\n}\n\n// TODO: Bounded?\nfunction fromColl(coll) {\n  var ch = (0, _csp.chan)(coll.length);\n  onto(ch, coll);\n  return ch;\n}\n\nfunction map(f, chs, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n  var length = chs.length;\n  // Array holding 1 round of values\n  var values = new Array(length);\n  // TODO: Not sure why we need a size-1 buffer here\n  var dchan = (0, _csp.chan)(1);\n  // How many more items this round\n  var dcount = void 0;\n  // put callbacks for each channel\n  var dcallbacks = new Array(length);\n  var callback = function callback(i) {\n    return function (value) {\n      values[i] = value;\n      dcount -= 1;\n      if (dcount === 0) {\n        (0, _process.putThenCallback)(dchan, values.slice(0));\n      }\n    };\n  };\n\n  for (var i = 0; i < length; i += 1) {\n    dcallbacks[i] = callback(i);\n  }\n\n  (0, _csp.go)(_regenerator2.default.mark(function _callee6() {\n    var _i, _values, _i2;\n\n    return _regenerator2.default.wrap(function _callee6$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            dcount = length;\n            // We could just launch n goroutines here, but for effciency we\n            // don't\n            for (_i = 0; _i < length; _i += 1) {\n              try {\n                (0, _process.takeThenCallback)(chs[_i], dcallbacks[_i]);\n              } catch (e) {\n                // FIX: Hmm why catching here?\n                dcount -= 1;\n              }\n            }\n\n            _context7.next = 4;\n            return (0, _process.take)(dchan);\n\n          case 4:\n            _values = _context7.sent;\n            _i2 = 0;\n\n          case 6:\n            if (!(_i2 < length)) {\n              _context7.next = 13;\n              break;\n            }\n\n            if (!(_values[_i2] === _channels.CLOSED)) {\n              _context7.next = 10;\n              break;\n            }\n\n            out.close();\n            return _context7.abrupt('return');\n\n          case 10:\n            _i2 += 1;\n            _context7.next = 6;\n            break;\n\n          case 13:\n            _context7.next = 15;\n            return (0, _process.put)(out, f.apply(undefined, (0, _toConsumableArray3.default)(_values)));\n\n          case 15:\n            _context7.next = 0;\n            break;\n\n          case 17:\n          case 'end':\n            return _context7.stop();\n        }\n      }\n    }, _callee6, this);\n  }));\n  return out;\n}\n\nfunction merge(chs, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n  var actives = chs.slice(0);\n  (0, _csp.go)(_regenerator2.default.mark(function _callee7() {\n    var r, value, i;\n    return _regenerator2.default.wrap(function _callee7$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!(actives.length === 0)) {\n              _context8.next = 2;\n              break;\n            }\n\n            return _context8.abrupt('break', 15);\n\n          case 2:\n            _context8.next = 4;\n            return (0, _process.alts)(actives);\n\n          case 4:\n            r = _context8.sent;\n            value = r.value;\n\n            if (!(value === _channels.CLOSED)) {\n              _context8.next = 11;\n              break;\n            }\n\n            // Remove closed channel\n            i = actives.indexOf(r.channel);\n\n            actives.splice(i, 1);\n            _context8.next = 13;\n            break;\n\n          case 11:\n            _context8.next = 13;\n            return (0, _process.put)(out, value);\n\n          case 13:\n            _context8.next = 0;\n            break;\n\n          case 15:\n            out.close();\n\n          case 16:\n          case 'end':\n            return _context8.stop();\n        }\n      }\n    }, _callee7, this);\n  }));\n  return out;\n}\n\nfunction into(coll, ch) {\n  var result = coll.slice(0);\n  return reduce(function (_result, item) {\n    _result.push(item);\n    return _result;\n  }, result, ch);\n}\n\nfunction take(n, ch, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n  (0, _csp.go)(_regenerator2.default.mark(function _callee8() {\n    var i, value;\n    return _regenerator2.default.wrap(function _callee8$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < n)) {\n              _context9.next = 12;\n              break;\n            }\n\n            _context9.next = 4;\n            return (0, _process.take)(ch);\n\n          case 4:\n            value = _context9.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context9.next = 7;\n              break;\n            }\n\n            return _context9.abrupt('break', 12);\n\n          case 7:\n            _context9.next = 9;\n            return (0, _process.put)(out, value);\n\n          case 9:\n            i += 1;\n            _context9.next = 1;\n            break;\n\n          case 12:\n            out.close();\n\n          case 13:\n          case 'end':\n            return _context9.stop();\n        }\n      }\n    }, _callee8, this);\n  }));\n  return out;\n}\n\nvar NOTHING = {};\n\nfunction unique(ch, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n  var last = NOTHING;\n  (0, _csp.go)(_regenerator2.default.mark(function _callee9() {\n    var value;\n    return _regenerator2.default.wrap(function _callee9$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return (0, _process.take)(ch);\n\n          case 2:\n            value = _context10.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context10.next = 5;\n              break;\n            }\n\n            return _context10.abrupt('break', 11);\n\n          case 5:\n            if (!(value !== last)) {\n              _context10.next = 9;\n              break;\n            }\n\n            last = value;\n            _context10.next = 9;\n            return (0, _process.put)(out, value);\n\n          case 9:\n            _context10.next = 0;\n            break;\n\n          case 11:\n            out.close();\n\n          case 12:\n          case 'end':\n            return _context10.stop();\n        }\n      }\n    }, _callee9, this);\n  }));\n  return out;\n}\n\nfunction partitionBy(f, ch, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n  var part = [];\n  var last = NOTHING;\n  (0, _csp.go)(_regenerator2.default.mark(function _callee10() {\n    var value, newItem;\n    return _regenerator2.default.wrap(function _callee10$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return (0, _process.take)(ch);\n\n          case 2:\n            value = _context11.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context11.next = 11;\n              break;\n            }\n\n            if (!(part.length > 0)) {\n              _context11.next = 7;\n              break;\n            }\n\n            _context11.next = 7;\n            return (0, _process.put)(out, part);\n\n          case 7:\n            out.close();\n            return _context11.abrupt('break', 22);\n\n          case 11:\n            newItem = f(value);\n\n            if (!(newItem === last || last === NOTHING)) {\n              _context11.next = 16;\n              break;\n            }\n\n            part.push(value);\n            _context11.next = 19;\n            break;\n\n          case 16:\n            _context11.next = 18;\n            return (0, _process.put)(out, part);\n\n          case 18:\n            part = [value];\n\n          case 19:\n            last = newItem;\n\n          case 20:\n            _context11.next = 0;\n            break;\n\n          case 22:\n          case 'end':\n            return _context11.stop();\n        }\n      }\n    }, _callee10, this);\n  }));\n  return out;\n}\n\nfunction partition(n, ch, bufferOrN) {\n  var out = (0, _csp.chan)(bufferOrN);\n  (0, _csp.go)(_regenerator2.default.mark(function _callee11() {\n    var part, i, value;\n    return _regenerator2.default.wrap(function _callee11$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            part = new Array(n);\n            i = 0;\n\n          case 2:\n            if (!(i < n)) {\n              _context12.next = 16;\n              break;\n            }\n\n            _context12.next = 5;\n            return (0, _process.take)(ch);\n\n          case 5:\n            value = _context12.sent;\n\n            if (!(value === _channels.CLOSED)) {\n              _context12.next = 12;\n              break;\n            }\n\n            if (!(i > 0)) {\n              _context12.next = 10;\n              break;\n            }\n\n            _context12.next = 10;\n            return (0, _process.put)(out, part.slice(0, i));\n\n          case 10:\n            out.close();\n            return _context12.abrupt('return');\n\n          case 12:\n            part[i] = value;\n\n          case 13:\n            i += 1;\n            _context12.next = 2;\n            break;\n\n          case 16:\n            _context12.next = 18;\n            return (0, _process.put)(out, part);\n\n          case 18:\n            _context12.next = 0;\n            break;\n\n          case 20:\n          case 'end':\n            return _context12.stop();\n        }\n      }\n    }, _callee11, this);\n  }));\n  return out;\n}\n\n// For channel identification\nvar genId = function () {\n  var i = 0;\n\n  return function () {\n    i += 1;\n    return '' + i;\n  };\n}();\n\nvar ID_ATTR = '__csp_channel_id';\n\nfunction chanId(ch) {\n  var id = ch[ID_ATTR];\n\n  if (!id) {\n    var generatedId = genId();\n\n    id = generatedId;\n    ch[ID_ATTR] = generatedId;\n  }\n\n  return id;\n}\n\nvar Tap = function Tap(channel, keepOpen) {\n  (0, _classCallCheck3.default)(this, Tap);\n\n  this.channel = channel;\n  this.keepOpen = keepOpen;\n};\n\nvar Mult = function () {\n  function Mult(ch) {\n    (0, _classCallCheck3.default)(this, Mult);\n\n    this.taps = {};\n    this.ch = ch;\n  }\n\n  (0, _createClass3.default)(Mult, [{\n    key: 'muxch',\n    value: function muxch() {\n      return this.ch;\n    }\n  }, {\n    key: 'tap',\n    value: function tap(ch, keepOpen) {\n      this.taps[chanId(ch)] = new Tap(ch, keepOpen);\n    }\n  }, {\n    key: 'untap',\n    value: function untap(ch) {\n      delete this.taps[chanId(ch)];\n    }\n  }, {\n    key: 'untapAll',\n    value: function untapAll() {\n      this.taps = {};\n    }\n  }]);\n  return Mult;\n}();\n\nfunction mult(ch) {\n  var m = new Mult(ch);\n  var dchan = (0, _csp.chan)(1);\n  var dcount = void 0;\n\n  function makeDoneCallback(tap) {\n    return function (stillOpen) {\n      dcount -= 1;\n      if (dcount === 0) {\n        (0, _process.putThenCallback)(dchan, true);\n      }\n      if (!stillOpen) {\n        m.untap(tap.channel);\n      }\n    };\n  }\n\n  (0, _csp.go)(_regenerator2.default.mark(function _callee12() {\n    var _this = this;\n\n    var _loop, _ret;\n\n    return _regenerator2.default.wrap(function _callee12$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            _loop = _regenerator2.default.mark(function _loop() {\n              var value, taps, t, initDcount;\n              return _regenerator2.default.wrap(function _loop$(_context13) {\n                while (1) {\n                  switch (_context13.prev = _context13.next) {\n                    case 0:\n                      _context13.next = 2;\n                      return (0, _process.take)(ch);\n\n                    case 2:\n                      value = _context13.sent;\n                      taps = m.taps;\n                      t = void 0;\n\n                      if (!(value === _channels.CLOSED)) {\n                        _context13.next = 9;\n                        break;\n                      }\n\n                      (0, _keys2.default)(taps).forEach(function (id) {\n                        t = taps[id];\n                        if (!t.keepOpen) {\n                          t.channel.close();\n                        }\n                      });\n\n                      // TODO: Is this necessary?\n                      m.untapAll();\n                      return _context13.abrupt('return', 'break');\n\n                    case 9:\n                      dcount = (0, _keys2.default)(taps).length;\n                      // XXX: This is because putAsync can actually call back\n                      // immediately. Fix that\n                      initDcount = dcount;\n                      // Put value on tapping channels...\n\n                      (0, _keys2.default)(taps).forEach(function (id) {\n                        t = taps[id];\n                        (0, _process.putThenCallback)(t.channel, value, makeDoneCallback(t));\n                      });\n                      // ... waiting for all puts to complete\n\n                      if (!(initDcount > 0)) {\n                        _context13.next = 15;\n                        break;\n                      }\n\n                      _context13.next = 15;\n                      return (0, _process.take)(dchan);\n\n                    case 15:\n                    case 'end':\n                      return _context13.stop();\n                  }\n                }\n              }, _loop, _this);\n            });\n\n          case 1:\n            return _context14.delegateYield(_loop(), 't0', 2);\n\n          case 2:\n            _ret = _context14.t0;\n\n            if (!(_ret === 'break')) {\n              _context14.next = 5;\n              break;\n            }\n\n            return _context14.abrupt('break', 7);\n\n          case 5:\n            _context14.next = 1;\n            break;\n\n          case 7:\n          case 'end':\n            return _context14.stop();\n        }\n      }\n    }, _callee12, this);\n  }));\n  return m;\n}\n\nmult.tap = function (m, ch, keepOpen) {\n  m.tap(ch, keepOpen);\n  return ch;\n};\n\nmult.untap = function (m, ch) {\n  m.untap(ch);\n};\n\nmult.untapAll = function (m) {\n  m.untapAll();\n};\n\nvar MIX_MUTE = 'mute';\nvar MIX_PAUSE = 'pause';\nvar MIX_SOLO = 'solo';\nvar VALID_SOLO_MODES = [MIX_MUTE, MIX_PAUSE];\n\nvar Mix = function () {\n  function Mix(ch) {\n    (0, _classCallCheck3.default)(this, Mix);\n\n    this.ch = ch;\n    this.stateMap = {};\n    this.change = (0, _csp.chan)();\n    this.soloMode = MIX_MUTE;\n  }\n\n  (0, _createClass3.default)(Mix, [{\n    key: '_changed',\n    value: function _changed() {\n      (0, _process.putThenCallback)(this.change, true);\n    }\n  }, {\n    key: '_getAllState',\n    value: function _getAllState() {\n      var stateMap = this.stateMap;\n      var solos = [];\n      var mutes = [];\n      var pauses = [];\n      var reads = void 0;\n\n      (0, _keys2.default)(stateMap).forEach(function (id) {\n        var chanData = stateMap[id];\n        var state = chanData.state;\n        var channel = chanData.channel;\n        if (state[MIX_SOLO]) {\n          solos.push(channel);\n        }\n        // TODO\n        if (state[MIX_MUTE]) {\n          mutes.push(channel);\n        }\n        if (state[MIX_PAUSE]) {\n          pauses.push(channel);\n        }\n      });\n\n      var i = void 0;\n      var n = void 0;\n      if (this.soloMode === MIX_PAUSE && solos.length > 0) {\n        n = solos.length;\n        reads = new Array(n + 1);\n        for (i = 0; i < n; i += 1) {\n          reads[i] = solos[i];\n        }\n        reads[n] = this.change;\n      } else {\n        reads = [];\n        (0, _keys2.default)(stateMap).forEach(function (id) {\n          var chanData = stateMap[id];\n          var channel = chanData.channel;\n          if (pauses.indexOf(channel) < 0) {\n            reads.push(channel);\n          }\n        });\n        reads.push(this.change);\n      }\n\n      return { solos: solos, mutes: mutes, reads: reads };\n    }\n  }, {\n    key: 'admix',\n    value: function admix(ch) {\n      this.stateMap[chanId(ch)] = {\n        channel: ch,\n        state: {}\n      };\n      this._changed();\n    }\n  }, {\n    key: 'unmix',\n    value: function unmix(ch) {\n      delete this.stateMap[chanId(ch)];\n      this._changed();\n    }\n  }, {\n    key: 'unmixAll',\n    value: function unmixAll() {\n      this.stateMap = {};\n      this._changed();\n    }\n  }, {\n    key: 'toggle',\n    value: function toggle(updateStateList) {\n      var _this2 = this;\n\n      // [[ch1, {}], [ch2, {solo: true}]];\n      var length = updateStateList.length;\n\n      var _loop2 = function _loop2(i) {\n        var ch = updateStateList[i][0];\n        var id = chanId(ch);\n        var updateState = updateStateList[i][1];\n        var chanData = _this2.stateMap[id];\n\n        if (!chanData) {\n          var defaultVal = {\n            channel: ch,\n            state: {}\n          };\n\n          chanData = defaultVal;\n          _this2.stateMap[id] = defaultVal;\n        }\n        (0, _keys2.default)(updateState).forEach(function (mode) {\n          chanData.state[mode] = updateState[mode];\n        });\n      };\n\n      for (var i = 0; i < length; i += 1) {\n        _loop2(i);\n      }\n      this._changed();\n    }\n  }, {\n    key: 'setSoloMode',\n    value: function setSoloMode(mode) {\n      if (VALID_SOLO_MODES.indexOf(mode) < 0) {\n        throw new Error('Mode must be one of: ', VALID_SOLO_MODES.join(', '));\n      }\n      this.soloMode = mode;\n      this._changed();\n    }\n  }]);\n  return Mix;\n}();\n\nfunction mix(out) {\n  var m = new Mix(out);\n  (0, _csp.go)(_regenerator2.default.mark(function _callee13() {\n    var state, result, _value, channel, solos, stillOpen;\n\n    return _regenerator2.default.wrap(function _callee13$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            state = m._getAllState();\n\n          case 1:\n            _context15.next = 3;\n            return (0, _process.alts)(state.reads);\n\n          case 3:\n            result = _context15.sent;\n            _value = result.value;\n            channel = result.channel;\n\n            if (!(_value === _channels.CLOSED)) {\n              _context15.next = 11;\n              break;\n            }\n\n            delete m.stateMap[chanId(channel)];\n            state = m._getAllState();\n            _context15.next = 22;\n            break;\n\n          case 11:\n            if (!(channel === m.change)) {\n              _context15.next = 15;\n              break;\n            }\n\n            state = m._getAllState();\n            _context15.next = 22;\n            break;\n\n          case 15:\n            solos = state.solos;\n\n            if (!(solos.indexOf(channel) > -1 || solos.length === 0 && !(state.mutes.indexOf(channel) > -1))) {\n              _context15.next = 22;\n              break;\n            }\n\n            _context15.next = 19;\n            return (0, _process.put)(out, _value);\n\n          case 19:\n            stillOpen = _context15.sent;\n\n            if (stillOpen) {\n              _context15.next = 22;\n              break;\n            }\n\n            return _context15.abrupt('break', 24);\n\n          case 22:\n            _context15.next = 1;\n            break;\n\n          case 24:\n          case 'end':\n            return _context15.stop();\n        }\n      }\n    }, _callee13, this);\n  }));\n  return m;\n}\n\nmix.add = function admix(m, ch) {\n  m.admix(ch);\n};\n\nmix.remove = function unmix(m, ch) {\n  m.unmix(ch);\n};\n\nmix.removeAll = function unmixAll(m) {\n  m.unmixAll();\n};\n\nmix.toggle = function toggle(m, updateStateList) {\n  m.toggle(updateStateList);\n};\n\nmix.setSoloMode = function setSoloMode(m, mode) {\n  m.setSoloMode(mode);\n};\n\nfunction constantlyNull() {\n  return null;\n}\n\nvar Pub = function () {\n  function Pub(ch, topicFn, bufferFn) {\n    (0, _classCallCheck3.default)(this, Pub);\n\n    this.ch = ch;\n    this.topicFn = topicFn;\n    this.bufferFn = bufferFn;\n    this.mults = {};\n  }\n\n  (0, _createClass3.default)(Pub, [{\n    key: '_ensureMult',\n    value: function _ensureMult(topic) {\n      var m = this.mults[topic];\n      var bufferFn = this.bufferFn;\n\n      if (!m) {\n        var defaultVal = mult((0, _csp.chan)(bufferFn(topic)));\n\n        m = defaultVal;\n        this.mults[topic] = defaultVal;\n      }\n      return m;\n    }\n  }, {\n    key: 'sub',\n    value: function sub(topic, ch, keepOpen) {\n      var m = this._ensureMult(topic);\n      return mult.tap(m, ch, keepOpen);\n    }\n  }, {\n    key: 'unsub',\n    value: function unsub(topic, ch) {\n      var m = this.mults[topic];\n      if (m) {\n        mult.untap(m, ch);\n      }\n    }\n  }, {\n    key: 'unsubAll',\n    value: function unsubAll(topic) {\n      if (topic === undefined) {\n        this.mults = {};\n      } else {\n        delete this.mults[topic];\n      }\n    }\n  }]);\n  return Pub;\n}();\n\nfunction pub(ch, topicFn) {\n  var bufferFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constantlyNull;\n\n  var p = new Pub(ch, topicFn, bufferFn);\n  (0, _csp.go)(_regenerator2.default.mark(function _callee14() {\n    var _this3 = this;\n\n    var _loop3, _ret3;\n\n    return _regenerator2.default.wrap(function _callee14$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            _loop3 = _regenerator2.default.mark(function _loop3() {\n              var value, mults, topic, m, stillOpen;\n              return _regenerator2.default.wrap(function _loop3$(_context16) {\n                while (1) {\n                  switch (_context16.prev = _context16.next) {\n                    case 0:\n                      _context16.next = 2;\n                      return (0, _process.take)(ch);\n\n                    case 2:\n                      value = _context16.sent;\n                      mults = p.mults;\n\n                      if (!(value === _channels.CLOSED)) {\n                        _context16.next = 7;\n                        break;\n                      }\n\n                      (0, _keys2.default)(mults).forEach(function (topic) {\n                        mults[topic].muxch().close();\n                      });\n                      return _context16.abrupt('return', 'break');\n\n                    case 7:\n                      // TODO: Somehow ensure/document that this must return a string\n                      // (otherwise use proper (hash)maps)\n                      topic = topicFn(value);\n                      m = mults[topic];\n\n                      if (!m) {\n                        _context16.next = 14;\n                        break;\n                      }\n\n                      _context16.next = 12;\n                      return (0, _process.put)(m.muxch(), value);\n\n                    case 12:\n                      stillOpen = _context16.sent;\n\n                      if (!stillOpen) {\n                        delete mults[topic];\n                      }\n\n                    case 14:\n                    case 'end':\n                      return _context16.stop();\n                  }\n                }\n              }, _loop3, _this3);\n            });\n\n          case 1:\n            return _context17.delegateYield(_loop3(), 't0', 2);\n\n          case 2:\n            _ret3 = _context17.t0;\n\n            if (!(_ret3 === 'break')) {\n              _context17.next = 5;\n              break;\n            }\n\n            return _context17.abrupt('break', 7);\n\n          case 5:\n            _context17.next = 1;\n            break;\n\n          case 7:\n          case 'end':\n            return _context17.stop();\n        }\n      }\n    }, _callee14, this);\n  }));\n  return p;\n}\n\npub.sub = function (p, topic, ch, keepOpen) {\n  return p.sub(topic, ch, keepOpen);\n};\n\npub.unsub = function (p, topic, ch) {\n  p.unsub(topic, ch);\n};\n\npub.unsubAll = function (p, topic) {\n  p.unsubAll(topic);\n};\n\nfunction pipelineInternal(n, to, from, close, taskFn) {\n  if (n <= 0) {\n    throw new Error('n must be positive');\n  }\n\n  var jobs = (0, _csp.chan)(n);\n  var results = (0, _csp.chan)(n);\n\n  (0, _times2.default)(n, function () {\n    (0, _csp.go)(_regenerator2.default.mark(function _callee15(_taskFn, _jobs, _results) {\n      var job;\n      return _regenerator2.default.wrap(function _callee15$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return (0, _process.take)(_jobs);\n\n            case 2:\n              job = _context18.sent;\n\n              if (_taskFn(job)) {\n                _context18.next = 6;\n                break;\n              }\n\n              _results.close();\n              return _context18.abrupt('break', 8);\n\n            case 6:\n              _context18.next = 0;\n              break;\n\n            case 8:\n            case 'end':\n              return _context18.stop();\n          }\n        }\n      }, _callee15, this);\n    }), [taskFn, jobs, results]);\n  });\n\n  (0, _csp.go)(_regenerator2.default.mark(function _callee16(_jobs, _from, _results) {\n    var v, p;\n    return _regenerator2.default.wrap(function _callee16$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            _context19.next = 2;\n            return (0, _process.take)(_from);\n\n          case 2:\n            v = _context19.sent;\n\n            if (!(v === _channels.CLOSED)) {\n              _context19.next = 6;\n              break;\n            }\n\n            _jobs.close();\n            return _context19.abrupt('break', 13);\n\n          case 6:\n            p = (0, _csp.chan)(1);\n            _context19.next = 9;\n            return (0, _process.put)(_jobs, [v, p]);\n\n          case 9:\n            _context19.next = 11;\n            return (0, _process.put)(_results, p);\n\n          case 11:\n            _context19.next = 0;\n            break;\n\n          case 13:\n          case 'end':\n            return _context19.stop();\n        }\n      }\n    }, _callee16, this);\n  }), [jobs, from, results]);\n\n  (0, _csp.go)(_regenerator2.default.mark(function _callee17(_results, _close, _to) {\n    var p, res, v;\n    return _regenerator2.default.wrap(function _callee17$(_context20) {\n      while (1) {\n        switch (_context20.prev = _context20.next) {\n          case 0:\n            _context20.next = 2;\n            return (0, _process.take)(_results);\n\n          case 2:\n            p = _context20.sent;\n\n            if (!(p === _channels.CLOSED)) {\n              _context20.next = 6;\n              break;\n            }\n\n            if (_close) {\n              _to.close();\n            }\n            return _context20.abrupt('break', 20);\n\n          case 6:\n            _context20.next = 8;\n            return (0, _process.take)(p);\n\n          case 8:\n            res = _context20.sent;\n\n          case 9:\n            _context20.next = 11;\n            return (0, _process.take)(res);\n\n          case 11:\n            v = _context20.sent;\n\n            if (!(v === _channels.CLOSED)) {\n              _context20.next = 14;\n              break;\n            }\n\n            return _context20.abrupt('break', 18);\n\n          case 14:\n            _context20.next = 16;\n            return (0, _process.put)(_to, v);\n\n          case 16:\n            _context20.next = 9;\n            break;\n\n          case 18:\n            _context20.next = 0;\n            break;\n\n          case 20:\n          case 'end':\n            return _context20.stop();\n        }\n      }\n    }, _callee17, this);\n  }), [results, close, to]);\n\n  return to;\n}\n\nfunction pipeline(to, xf, from, keepOpen, exHandler) {\n  function taskFn(job) {\n    if (job === _channels.CLOSED) {\n      return null;\n    }\n\n    var _job = (0, _slicedToArray3.default)(job, 2),\n        v = _job[0],\n        p = _job[1];\n\n    var res = (0, _csp.chan)(1, xf, exHandler);\n\n    (0, _csp.go)(_regenerator2.default.mark(function _callee18(ch, value) {\n      return _regenerator2.default.wrap(function _callee18$(_context21) {\n        while (1) {\n          switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return (0, _process.put)(ch, value);\n\n            case 2:\n              res.close();\n\n            case 3:\n            case 'end':\n              return _context21.stop();\n          }\n        }\n      }, _callee18, this);\n    }), [res, v]);\n\n    (0, _process.putThenCallback)(p, res);\n\n    return true;\n  }\n\n  return pipelineInternal(1, to, from, !keepOpen, taskFn);\n}\n\nfunction pipelineAsync(n, to, af, from, keepOpen) {\n  function taskFn(job) {\n    if (job === _channels.CLOSED) {\n      return null;\n    }\n\n    var _job2 = (0, _slicedToArray3.default)(job, 2),\n        v = _job2[0],\n        p = _job2[1];\n\n    var res = (0, _csp.chan)(1);\n    af(v, res);\n    (0, _process.putThenCallback)(p, res);\n\n    return true;\n  }\n\n  return pipelineInternal(n, to, from, !keepOpen, taskFn);\n}\n// Possible \"fluid\" interfaces:\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc],\n//   [into, []]\n// )\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc, _],\n//   [into, [], _]\n// )\n\n// wrap()\n//   .fromColl([1, 2, 3, 4])\n//   .mapFrom(inc)\n//   .into([])\n//   .unwrap();","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/csp.core.js":"\nimport { fixed, promise } from './impl/buffers';\n\nimport { putThenCallback, Process } from './impl/process';\nimport { chan as channel, Channel, CLOSED } from './impl/channels';\n\nexport function spawn(gen) {\n  const ch = channel(fixed(1));\n  const process = new Process(gen, value => {\n    if (value === CLOSED) {\n      ch.close();\n    } else {\n      putThenCallback(ch, value, () => ch.close());\n    }\n  });\n\n  process.run();\n  return ch;\n}\n\nexport function go(f, args = []) {\n  return spawn(f(...args));\n}\n\nexport function chan(bufferOrNumber, xform, exHandler) {\n  if (typeof bufferOrNumber === 'number') {\n    return channel(bufferOrNumber === 0 ? null : fixed(bufferOrNumber), xform, exHandler);\n  }\n\n  return channel(bufferOrNumber, xform, exHandler);\n}\n\nexport function promiseChan(xform, exHandler) {\n  return channel(promise(), xform, exHandler);\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/csp.js":"import { fixed, dropping, sliding, promise } from './impl/buffers';\nimport { mapFrom, mapInto, filterFrom, filterInto, removeFrom, removeInto, mapcatFrom, mapcatInto, pipe, split, reduce, onto, fromColl, map, merge, into, take as takeN, unique, partitionBy, partition, mult, mix, pub, pipeline, pipelineAsync } from './csp.operations';\n\nexport const operations = {\n  mapFrom,\n  mapInto,\n  filterFrom,\n  filterInto,\n  removeFrom,\n  removeInto,\n  mapcatFrom,\n  mapcatInto,\n  pipe,\n  split,\n  reduce,\n  onto,\n  fromColl,\n  map,\n  merge,\n  into,\n  unique,\n  partitionBy,\n  partition,\n  mult,\n  mix,\n  pub,\n  pipeline,\n  pipelineAsync,\n  take: takeN\n};\nexport const buffers = { fixed, dropping, sliding, promise };\nexport { CLOSED } from './impl/channels';\nexport { timeout } from './impl/timers';\nexport { DEFAULT } from './impl/results';\nexport { put, take, offer, poll, sleep, alts, putThenCallback as putAsync, takeThenCallback as takeAsync, NO_VALUE } from './impl/process';\nexport { spawn, go, chan, promiseChan } from './csp.core';","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/csp.operations.js":"import _Object$keys from 'babel-runtime/core-js/object/keys';\nimport times from 'lodash/times';\nimport { Box } from './impl/boxes';\nimport { CLOSED } from './impl/channels';\nimport { take as _take, put, takeThenCallback as takeAsync, putThenCallback as putAsync, alts } from './impl/process';\nimport { go, chan } from './csp.core';\n\nexport function mapFrom(f, ch) {\n  return {\n    isClosed() {\n      return ch.isClosed();\n    },\n    close() {\n      ch.close();\n    },\n    put(value, handler) {\n      return ch.put(value, handler);\n    },\n    take(handler) {\n      const result = ch.take({\n        isActive() {\n          return handler.isActive();\n        },\n        commit() {\n          const takeCallback = handler.commit();\n          return value => takeCallback(value === CLOSED ? CLOSED : f(value));\n        }\n      });\n\n      if (result) {\n        const value = result.value;\n        return new Box(value === CLOSED ? CLOSED : f(value));\n      }\n\n      return null;\n    }\n  };\n}\n\nexport function mapInto(f, ch) {\n  return {\n    isClosed() {\n      return ch.isClosed();\n    },\n    close() {\n      ch.close();\n    },\n    put(value, handler) {\n      return ch.put(f(value), handler);\n    },\n    take(handler) {\n      return ch.take(handler);\n    }\n  };\n}\n\nexport function filterFrom(p, ch, bufferOrN) {\n  const out = chan(bufferOrN);\n\n  go(function* () {\n    for (;;) {\n      const value = yield _take(ch);\n      if (value === CLOSED) {\n        out.close();\n        break;\n      }\n\n      if (p(value)) {\n        yield put(out, value);\n      }\n    }\n  });\n  return out;\n}\n\nexport function filterInto(p, ch) {\n  return {\n    isClosed() {\n      return ch.isClosed();\n    },\n    close() {\n      ch.close();\n    },\n    put(value, handler) {\n      if (p(value)) {\n        return ch.put(value, handler);\n      }\n\n      return new Box(!ch.isClosed());\n    },\n    take(handler) {\n      return ch.take(handler);\n    }\n  };\n}\n\nexport function removeFrom(p, ch) {\n  return filterFrom(value => !p(value), ch);\n}\n\nexport function removeInto(p, ch) {\n  return filterInto(value => !p(value), ch);\n}\n\nfunction* mapcat(f, src, dst) {\n  for (;;) {\n    const value = yield _take(src);\n    if (value === CLOSED) {\n      dst.close();\n      break;\n    } else {\n      const seq = f(value);\n      const length = seq.length;\n      for (let i = 0; i < length; i += 1) {\n        yield put(dst, seq[i]);\n      }\n      if (dst.isClosed()) {\n        break;\n      }\n    }\n  }\n}\n\nexport function mapcatFrom(f, ch, bufferOrN) {\n  const out = chan(bufferOrN);\n  go(mapcat, [f, ch, out]);\n  return out;\n}\n\nexport function mapcatInto(f, ch, bufferOrN) {\n  const src = chan(bufferOrN);\n  go(mapcat, [f, src, ch]);\n  return src;\n}\n\nexport function pipe(src, dst, keepOpen) {\n  go(function* () {\n    for (;;) {\n      const value = yield _take(src);\n      if (value === CLOSED) {\n        if (!keepOpen) {\n          dst.close();\n        }\n        break;\n      }\n      if (!(yield put(dst, value))) {\n        break;\n      }\n    }\n  });\n  return dst;\n}\n\nexport function split(p, ch, trueBufferOrN, falseBufferOrN) {\n  const tch = chan(trueBufferOrN);\n  const fch = chan(falseBufferOrN);\n  go(function* () {\n    for (;;) {\n      const value = yield _take(ch);\n      if (value === CLOSED) {\n        tch.close();\n        fch.close();\n        break;\n      }\n      yield put(p(value) ? tch : fch, value);\n    }\n  });\n  return [tch, fch];\n}\n\nexport function reduce(f, init, ch) {\n  return go(function* () {\n    let result = init;\n    for (;;) {\n      const value = yield _take(ch);\n\n      if (value === CLOSED) {\n        return result;\n      }\n\n      result = f(result, value);\n    }\n  }, [], true);\n}\n\nexport function onto(ch, coll, keepOpen) {\n  return go(function* () {\n    const length = coll.length;\n    // FIX: Should be a generic looping interface (for...in?)\n    for (let i = 0; i < length; i += 1) {\n      yield put(ch, coll[i]);\n    }\n    if (!keepOpen) {\n      ch.close();\n    }\n  });\n}\n\n// TODO: Bounded?\nexport function fromColl(coll) {\n  const ch = chan(coll.length);\n  onto(ch, coll);\n  return ch;\n}\n\nexport function map(f, chs, bufferOrN) {\n  const out = chan(bufferOrN);\n  const length = chs.length;\n  // Array holding 1 round of values\n  const values = new Array(length);\n  // TODO: Not sure why we need a size-1 buffer here\n  const dchan = chan(1);\n  // How many more items this round\n  let dcount;\n  // put callbacks for each channel\n  const dcallbacks = new Array(length);\n  const callback = i => value => {\n    values[i] = value;\n    dcount -= 1;\n    if (dcount === 0) {\n      putAsync(dchan, values.slice(0));\n    }\n  };\n\n  for (let i = 0; i < length; i += 1) {\n    dcallbacks[i] = callback(i);\n  }\n\n  go(function* () {\n    for (;;) {\n      dcount = length;\n      // We could just launch n goroutines here, but for effciency we\n      // don't\n      for (let i = 0; i < length; i += 1) {\n        try {\n          takeAsync(chs[i], dcallbacks[i]);\n        } catch (e) {\n          // FIX: Hmm why catching here?\n          dcount -= 1;\n        }\n      }\n\n      const _values = yield _take(dchan);\n      for (let i = 0; i < length; i += 1) {\n        if (_values[i] === CLOSED) {\n          out.close();\n          return;\n        }\n      }\n      yield put(out, f(..._values));\n    }\n  });\n  return out;\n}\n\nexport function merge(chs, bufferOrN) {\n  const out = chan(bufferOrN);\n  const actives = chs.slice(0);\n  go(function* () {\n    for (;;) {\n      if (actives.length === 0) {\n        break;\n      }\n      const r = yield alts(actives);\n      const value = r.value;\n      if (value === CLOSED) {\n        // Remove closed channel\n        const i = actives.indexOf(r.channel);\n        actives.splice(i, 1);\n      } else {\n        yield put(out, value);\n      }\n    }\n    out.close();\n  });\n  return out;\n}\n\nexport function into(coll, ch) {\n  const result = coll.slice(0);\n  return reduce((_result, item) => {\n    _result.push(item);\n    return _result;\n  }, result, ch);\n}\n\nexport function take(n, ch, bufferOrN) {\n  const out = chan(bufferOrN);\n  go(function* () {\n    for (let i = 0; i < n; i += 1) {\n      const value = yield _take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nconst NOTHING = {};\n\nexport function unique(ch, bufferOrN) {\n  const out = chan(bufferOrN);\n  let last = NOTHING;\n  go(function* () {\n    for (;;) {\n      const value = yield _take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      if (value !== last) {\n        last = value;\n        yield put(out, value);\n      }\n    }\n    out.close();\n  });\n  return out;\n}\n\nexport function partitionBy(f, ch, bufferOrN) {\n  const out = chan(bufferOrN);\n  let part = [];\n  let last = NOTHING;\n  go(function* () {\n    for (;;) {\n      const value = yield _take(ch);\n      if (value === CLOSED) {\n        if (part.length > 0) {\n          yield put(out, part);\n        }\n        out.close();\n        break;\n      } else {\n        const newItem = f(value);\n        if (newItem === last || last === NOTHING) {\n          part.push(value);\n        } else {\n          yield put(out, part);\n          part = [value];\n        }\n        last = newItem;\n      }\n    }\n  });\n  return out;\n}\n\nexport function partition(n, ch, bufferOrN) {\n  const out = chan(bufferOrN);\n  go(function* () {\n    for (;;) {\n      const part = new Array(n);\n      for (let i = 0; i < n; i += 1) {\n        const value = yield _take(ch);\n        if (value === CLOSED) {\n          if (i > 0) {\n            yield put(out, part.slice(0, i));\n          }\n          out.close();\n          return;\n        }\n        part[i] = value;\n      }\n      yield put(out, part);\n    }\n  });\n  return out;\n}\n\n// For channel identification\nconst genId = (() => {\n  let i = 0;\n\n  return () => {\n    i += 1;\n    return `${i}`;\n  };\n})();\n\nconst ID_ATTR = '__csp_channel_id';\n\nfunction chanId(ch) {\n  let id = ch[ID_ATTR];\n\n  if (!id) {\n    const generatedId = genId();\n\n    id = generatedId;\n    ch[ID_ATTR] = generatedId;\n  }\n\n  return id;\n}\n\nclass Tap {\n  constructor(channel, keepOpen) {\n    this.channel = channel;\n    this.keepOpen = keepOpen;\n  }\n}\n\nclass Mult {\n  constructor(ch) {\n    this.taps = {};\n    this.ch = ch;\n  }\n\n  muxch() {\n    return this.ch;\n  }\n\n  tap(ch, keepOpen) {\n    this.taps[chanId(ch)] = new Tap(ch, keepOpen);\n  }\n\n  untap(ch) {\n    delete this.taps[chanId(ch)];\n  }\n\n  untapAll() {\n    this.taps = {};\n  }\n}\n\nexport function mult(ch) {\n  const m = new Mult(ch);\n  const dchan = chan(1);\n  let dcount;\n\n  function makeDoneCallback(tap) {\n    return stillOpen => {\n      dcount -= 1;\n      if (dcount === 0) {\n        putAsync(dchan, true);\n      }\n      if (!stillOpen) {\n        m.untap(tap.channel);\n      }\n    };\n  }\n\n  go(function* () {\n    for (;;) {\n      const value = yield _take(ch);\n      const taps = m.taps;\n      let t;\n\n      if (value === CLOSED) {\n        _Object$keys(taps).forEach(id => {\n          t = taps[id];\n          if (!t.keepOpen) {\n            t.channel.close();\n          }\n        });\n\n        // TODO: Is this necessary?\n        m.untapAll();\n        break;\n      }\n      dcount = _Object$keys(taps).length;\n      // XXX: This is because putAsync can actually call back\n      // immediately. Fix that\n      const initDcount = dcount;\n      // Put value on tapping channels...\n      _Object$keys(taps).forEach(id => {\n        t = taps[id];\n        putAsync(t.channel, value, makeDoneCallback(t));\n      });\n      // ... waiting for all puts to complete\n      if (initDcount > 0) {\n        yield _take(dchan);\n      }\n    }\n  });\n  return m;\n}\n\nmult.tap = (m, ch, keepOpen) => {\n  m.tap(ch, keepOpen);\n  return ch;\n};\n\nmult.untap = (m, ch) => {\n  m.untap(ch);\n};\n\nmult.untapAll = m => {\n  m.untapAll();\n};\n\nconst MIX_MUTE = 'mute';\nconst MIX_PAUSE = 'pause';\nconst MIX_SOLO = 'solo';\nconst VALID_SOLO_MODES = [MIX_MUTE, MIX_PAUSE];\n\nclass Mix {\n  constructor(ch) {\n    this.ch = ch;\n    this.stateMap = {};\n    this.change = chan();\n    this.soloMode = MIX_MUTE;\n  }\n\n  _changed() {\n    putAsync(this.change, true);\n  }\n\n  _getAllState() {\n    const stateMap = this.stateMap;\n    const solos = [];\n    const mutes = [];\n    const pauses = [];\n    let reads;\n\n    _Object$keys(stateMap).forEach(id => {\n      const chanData = stateMap[id];\n      const state = chanData.state;\n      const channel = chanData.channel;\n      if (state[MIX_SOLO]) {\n        solos.push(channel);\n      }\n      // TODO\n      if (state[MIX_MUTE]) {\n        mutes.push(channel);\n      }\n      if (state[MIX_PAUSE]) {\n        pauses.push(channel);\n      }\n    });\n\n    let i;\n    let n;\n    if (this.soloMode === MIX_PAUSE && solos.length > 0) {\n      n = solos.length;\n      reads = new Array(n + 1);\n      for (i = 0; i < n; i += 1) {\n        reads[i] = solos[i];\n      }\n      reads[n] = this.change;\n    } else {\n      reads = [];\n      _Object$keys(stateMap).forEach(id => {\n        const chanData = stateMap[id];\n        const channel = chanData.channel;\n        if (pauses.indexOf(channel) < 0) {\n          reads.push(channel);\n        }\n      });\n      reads.push(this.change);\n    }\n\n    return { solos, mutes, reads };\n  }\n\n  admix(ch) {\n    this.stateMap[chanId(ch)] = {\n      channel: ch,\n      state: {}\n    };\n    this._changed();\n  }\n\n  unmix(ch) {\n    delete this.stateMap[chanId(ch)];\n    this._changed();\n  }\n\n  unmixAll() {\n    this.stateMap = {};\n    this._changed();\n  }\n\n  toggle(updateStateList) {\n    // [[ch1, {}], [ch2, {solo: true}]];\n    const length = updateStateList.length;\n    for (let i = 0; i < length; i += 1) {\n      const ch = updateStateList[i][0];\n      const id = chanId(ch);\n      const updateState = updateStateList[i][1];\n      let chanData = this.stateMap[id];\n\n      if (!chanData) {\n        const defaultVal = {\n          channel: ch,\n          state: {}\n        };\n\n        chanData = defaultVal;\n        this.stateMap[id] = defaultVal;\n      }\n      _Object$keys(updateState).forEach(mode => {\n        chanData.state[mode] = updateState[mode];\n      });\n    }\n    this._changed();\n  }\n\n  setSoloMode(mode) {\n    if (VALID_SOLO_MODES.indexOf(mode) < 0) {\n      throw new Error('Mode must be one of: ', VALID_SOLO_MODES.join(', '));\n    }\n    this.soloMode = mode;\n    this._changed();\n  }\n}\n\nexport function mix(out) {\n  const m = new Mix(out);\n  go(function* () {\n    let state = m._getAllState();\n\n    for (;;) {\n      const result = yield alts(state.reads);\n      const value = result.value;\n      const channel = result.channel;\n\n      if (value === CLOSED) {\n        delete m.stateMap[chanId(channel)];\n        state = m._getAllState();\n      } else if (channel === m.change) {\n        state = m._getAllState();\n      } else {\n        const solos = state.solos;\n\n        if (solos.indexOf(channel) > -1 || solos.length === 0 && !(state.mutes.indexOf(channel) > -1)) {\n          const stillOpen = yield put(out, value);\n          if (!stillOpen) {\n            break;\n          }\n        }\n      }\n    }\n  });\n  return m;\n}\n\nmix.add = function admix(m, ch) {\n  m.admix(ch);\n};\n\nmix.remove = function unmix(m, ch) {\n  m.unmix(ch);\n};\n\nmix.removeAll = function unmixAll(m) {\n  m.unmixAll();\n};\n\nmix.toggle = function toggle(m, updateStateList) {\n  m.toggle(updateStateList);\n};\n\nmix.setSoloMode = function setSoloMode(m, mode) {\n  m.setSoloMode(mode);\n};\n\nfunction constantlyNull() {\n  return null;\n}\n\nclass Pub {\n  constructor(ch, topicFn, bufferFn) {\n    this.ch = ch;\n    this.topicFn = topicFn;\n    this.bufferFn = bufferFn;\n    this.mults = {};\n  }\n\n  _ensureMult(topic) {\n    let m = this.mults[topic];\n    const bufferFn = this.bufferFn;\n\n    if (!m) {\n      const defaultVal = mult(chan(bufferFn(topic)));\n\n      m = defaultVal;\n      this.mults[topic] = defaultVal;\n    }\n    return m;\n  }\n\n  sub(topic, ch, keepOpen) {\n    const m = this._ensureMult(topic);\n    return mult.tap(m, ch, keepOpen);\n  }\n\n  unsub(topic, ch) {\n    const m = this.mults[topic];\n    if (m) {\n      mult.untap(m, ch);\n    }\n  }\n\n  unsubAll(topic) {\n    if (topic === undefined) {\n      this.mults = {};\n    } else {\n      delete this.mults[topic];\n    }\n  }\n}\n\nexport function pub(ch, topicFn, bufferFn = constantlyNull) {\n  const p = new Pub(ch, topicFn, bufferFn);\n  go(function* () {\n    for (;;) {\n      const value = yield _take(ch);\n      const mults = p.mults;\n      if (value === CLOSED) {\n        _Object$keys(mults).forEach(topic => {\n          mults[topic].muxch().close();\n        });\n        break;\n      }\n      // TODO: Somehow ensure/document that this must return a string\n      // (otherwise use proper (hash)maps)\n      const topic = topicFn(value);\n      const m = mults[topic];\n      if (m) {\n        const stillOpen = yield put(m.muxch(), value);\n        if (!stillOpen) {\n          delete mults[topic];\n        }\n      }\n    }\n  });\n  return p;\n}\n\npub.sub = (p, topic, ch, keepOpen) => p.sub(topic, ch, keepOpen);\n\npub.unsub = (p, topic, ch) => {\n  p.unsub(topic, ch);\n};\n\npub.unsubAll = (p, topic) => {\n  p.unsubAll(topic);\n};\n\nfunction pipelineInternal(n, to, from, close, taskFn) {\n  if (n <= 0) {\n    throw new Error('n must be positive');\n  }\n\n  const jobs = chan(n);\n  const results = chan(n);\n\n  times(n, () => {\n    go(function* (_taskFn, _jobs, _results) {\n      for (;;) {\n        const job = yield _take(_jobs);\n\n        if (!_taskFn(job)) {\n          _results.close();\n          break;\n        }\n      }\n    }, [taskFn, jobs, results]);\n  });\n\n  go(function* (_jobs, _from, _results) {\n    for (;;) {\n      const v = yield _take(_from);\n\n      if (v === CLOSED) {\n        _jobs.close();\n        break;\n      }\n\n      const p = chan(1);\n\n      yield put(_jobs, [v, p]);\n      yield put(_results, p);\n    }\n  }, [jobs, from, results]);\n\n  go(function* (_results, _close, _to) {\n    for (;;) {\n      const p = yield _take(_results);\n\n      if (p === CLOSED) {\n        if (_close) {\n          _to.close();\n        }\n        break;\n      }\n\n      const res = yield _take(p);\n\n      for (;;) {\n        const v = yield _take(res);\n\n        if (v === CLOSED) {\n          break;\n        }\n\n        yield put(_to, v);\n      }\n    }\n  }, [results, close, to]);\n\n  return to;\n}\n\nexport function pipeline(to, xf, from, keepOpen, exHandler) {\n  function taskFn(job) {\n    if (job === CLOSED) {\n      return null;\n    }\n\n    const [v, p] = job;\n    const res = chan(1, xf, exHandler);\n\n    go(function* (ch, value) {\n      yield put(ch, value);\n      res.close();\n    }, [res, v]);\n\n    putAsync(p, res);\n\n    return true;\n  }\n\n  return pipelineInternal(1, to, from, !keepOpen, taskFn);\n}\n\nexport function pipelineAsync(n, to, af, from, keepOpen) {\n  function taskFn(job) {\n    if (job === CLOSED) {\n      return null;\n    }\n\n    const [v, p] = job;\n    const res = chan(1);\n    af(v, res);\n    putAsync(p, res);\n\n    return true;\n  }\n\n  return pipelineInternal(n, to, from, !keepOpen, taskFn);\n}\n// Possible \"fluid\" interfaces:\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc],\n//   [into, []]\n// )\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc, _],\n//   [into, [], _]\n// )\n\n// wrap()\n//   .fromColl([1, 2, 3, 4])\n//   .mapFrom(inc)\n//   .into([])\n//   .unwrap();","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/src/csp.js":"import { fixed, dropping, sliding, promise } from './impl/buffers';\nimport {\n  mapFrom, mapInto, filterFrom, filterInto,\n  removeFrom, removeInto, mapcatFrom, mapcatInto,\n  pipe, split, reduce, onto, fromColl, map,\n  merge, into, take as takeN,\n  unique, partitionBy, partition, mult, mix, pub,\n  pipeline, pipelineAsync,\n} from './csp.operations';\n\nexport const operations = {\n  mapFrom,\n  mapInto,\n  filterFrom,\n  filterInto,\n  removeFrom,\n  removeInto,\n  mapcatFrom,\n  mapcatInto,\n  pipe,\n  split,\n  reduce,\n  onto,\n  fromColl,\n  map,\n  merge,\n  into,\n  unique,\n  partitionBy,\n  partition,\n  mult,\n  mix,\n  pub,\n  pipeline,\n  pipelineAsync,\n  take: takeN,\n};\nexport const buffers = { fixed, dropping, sliding, promise };\nexport { CLOSED } from './impl/channels';\nexport { timeout } from './impl/timers';\nexport { DEFAULT } from './impl/results';\nexport {\n  put, take,\n  offer, poll,\n  sleep, alts,\n  putThenCallback as putAsync, takeThenCallback as takeAsync,\n  NO_VALUE,\n} from './impl/process';\nexport { spawn, go, chan, promiseChan } from './csp.core';\n","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/boxes.js":"\n\nexport class Box {\n\n  constructor(value) {\n    this.value = value;\n  }\n}\n\n\nexport class PutBox {\n\n  constructor(handler, value) {\n    this.handler = handler;\n    this.value = value;\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/buffers.js":"function acopy(src, srcStart, dest, destStart, len) {\n  for (let count = 0; count < len; count += 1) {\n    dest[destStart + count] = src[srcStart + count];\n  }\n}\n\nexport class RingBuffer {\n\n  constructor(head, tail, length, arr) {\n    this.head = head;\n    this.tail = tail;\n    this.length = length;\n    this.arr = arr;\n  }\n\n  pop() {\n    if (this.length !== 0) {\n      const elem = this.arr[this.tail];\n\n      this.arr[this.tail] = undefined;\n      this.tail = (this.tail + 1) % this.arr.length;\n      this.length -= 1;\n\n      return elem;\n    }\n\n    return undefined;\n  }\n\n  unshift(element) {\n    this.arr[this.head] = element;\n    this.head = (this.head + 1) % this.arr.length;\n    this.length += 1;\n  }\n\n  unboundedUnshift(element) {\n    if (this.length + 1 === this.arr.length) {\n      this.resize();\n    }\n    this.unshift(element);\n  }\n\n  resize() {\n    const newArrSize = this.arr.length * 2;\n    const newArr = new Array(newArrSize);\n\n    if (this.tail < this.head) {\n      acopy(this.arr, this.tail, newArr, 0, this.length);\n      this.tail = 0;\n      this.head = this.length;\n      this.arr = newArr;\n    } else if (this.tail > this.head) {\n      acopy(this.arr, this.tail, newArr, 0, this.arr.length - this.tail);\n      acopy(this.arr, 0, newArr, this.arr.length - this.tail, this.head);\n      this.tail = 0;\n      this.head = this.length;\n      this.arr = newArr;\n    } else if (this.tail === this.head) {\n      this.tail = 0;\n      this.head = 0;\n      this.arr = newArr;\n    }\n  }\n\n  cleanup(predicate) {\n    for (let i = this.length; i > 0; i -= 1) {\n      const value = this.pop();\n\n      if (predicate(value)) {\n        this.unshift(value);\n      }\n    }\n  }\n}\n\nexport function ring(n) {\n  if (n <= 0) {\n    throw new Error(\"Can't create a ring buffer of size 0\");\n  }\n\n  return new RingBuffer(0, 0, 0, new Array(n));\n}\n\n/**\n * Returns a buffer that is considered \"full\" when it reaches size n,\n * but still accepts additional items, effectively allow overflowing.\n * The overflowing behavior is useful for supporting \"expanding\"\n * transducers, where we want to check if a buffer is full before\n * running the transduced step function, while still allowing a\n * transduced step to expand into multiple \"essence\" steps.\n */\nexport class FixedBuffer {\n\n  constructor(buffer, n) {\n    this.buffer = buffer;\n    this.n = n;\n  }\n\n  isFull() {\n    return this.buffer.length === this.n;\n  }\n\n  remove() {\n    return this.buffer.pop();\n  }\n\n  add(item) {\n    this.buffer.unboundedUnshift(item);\n  }\n\n  closeBuffer() {} // eslint-disable-line\n\n  count() {\n    return this.buffer.length;\n  }\n}\n\nexport function fixed(n) {\n  return new FixedBuffer(ring(n), n);\n}\n\nexport class DroppingBuffer {\n\n  constructor(buffer, n) {\n    this.buffer = buffer;\n    this.n = n;\n  }\n\n  isFull() {\n    // eslint-disable-line\n    return false;\n  }\n\n  remove() {\n    return this.buffer.pop();\n  }\n\n  add(item) {\n    if (this.buffer.length !== this.n) {\n      this.buffer.unshift(item);\n    }\n  }\n\n  closeBuffer() {} // eslint-disable-line\n\n  count() {\n    return this.buffer.length;\n  }\n}\n\nexport function dropping(n) {\n  return new DroppingBuffer(ring(n), n);\n}\n\nexport class SlidingBuffer {\n\n  constructor(buffer, n) {\n    this.buffer = buffer;\n    this.n = n;\n  }\n\n  isFull() {\n    // eslint-disable-line\n    return false;\n  }\n\n  remove() {\n    return this.buffer.pop();\n  }\n\n  add(item) {\n    if (this.buffer.length === this.n) {\n      this.remove();\n    }\n\n    this.buffer.unshift(item);\n  }\n\n  closeBuffer() {} // eslint-disable-line\n\n  count() {\n    return this.buffer.length;\n  }\n}\n\nexport function sliding(n) {\n  return new SlidingBuffer(ring(n), n);\n}\n\nexport class PromiseBuffer {\n\n  constructor(value) {\n    this.value = value;\n  }\n\n  isFull() {\n    // eslint-disable-line\n    return false;\n  }\n\n  remove() {\n    return this.value;\n  }\n\n  add(item) {\n    if (PromiseBuffer.isUndelivered(this.value)) {\n      this.value = item;\n    }\n  }\n\n  closeBuffer() {\n    if (PromiseBuffer.isUndelivered(this.value)) {\n      this.value = null;\n    }\n  }\n\n  count() {\n    return PromiseBuffer.isUndelivered(this.value) ? 0 : 1;\n  }\n}\n\nPromiseBuffer.NO_VALUE = '@@PromiseBuffer/NO_VALUE';\n\nPromiseBuffer.isUndelivered = value => PromiseBuffer.NO_VALUE === value;\n\nexport function promise() {\n  return new PromiseBuffer(PromiseBuffer.NO_VALUE);\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/channels.js":"\nimport { RingBuffer, ring } from './buffers';\n\nimport { Box, PutBox } from './boxes';\nimport { isReduced, flush, taskScheduler } from './utils';\n\n\nexport const MAX_DIRTY = 64;\nexport const MAX_QUEUE_SIZE = 1024;\nexport const CLOSED = null;\n\nexport class Channel {\n\n  constructor(takes, puts, buf, xform) {\n    this.buf = buf;\n    this.xform = xform;\n    this.takes = takes;\n    this.puts = puts;\n    this.dirtyTakes = 0;\n    this.dirtyPuts = 0;\n    this.closed = false;\n  }\n\n  put(value, handler) {\n    if (value === CLOSED) {\n      throw new Error('Cannot put CLOSED on a channel.');\n    }\n\n    // TODO: I'm not sure how this can happen, because the operations\n    // are registered in 1 tick, and the only way for this to be inactive\n    // is for a previous operation in the same alt to have returned\n    // immediately, which would have short-circuited to prevent this to\n    // be ever register anyway. The same thing goes for the active check\n    // in \"take\".\n    if (!handler.isActive()) {\n      return null;\n    }\n\n    if (this.closed) {\n      handler.commit();\n      return new Box(false);\n    }\n\n    // Soak the value through the buffer first, even if there is a\n    // pending taker. This way the step function has a chance to act on the\n    // value.\n    if (this.buf && !this.buf.isFull()) {\n      handler.commit();\n      const done = isReduced(this.xform['@@transducer/step'](this.buf, value));\n\n      // flow-ignore\n      while (this.buf.count() > 0 && this.takes.length > 0) {\n        const taker = this.takes.pop();\n\n        // flow-ignore\n        if (taker.isActive()) {\n          // flow-ignore\n          taskScheduler(taker.commit(), this.buf.remove());\n        }\n      }\n\n      if (done) {\n        this.close();\n      }\n      return new Box(true);\n    }\n\n    // Either the buffer is full, in which case there won't be any\n    // pending takes, or we don't have a buffer, in which case this loop\n    // fulfills the first of them that is active (note that we don't\n    // have to worry about transducers here since we require a buffer\n    // for that).\n    while (this.takes.length > 0) {\n      const taker = this.takes.pop();\n\n      // flow-ignore\n      if (taker.isActive()) {\n        handler.commit();\n        // flow-ignore\n        taskScheduler(taker.commit(), value);\n        return new Box(true);\n      }\n    }\n\n    // No buffer, full buffer, no pending takes. Queue this put now if blockable.\n    if (this.dirtyPuts > MAX_DIRTY) {\n      this.puts.cleanup(putter => putter.handler.isActive());\n      this.dirtyPuts = 0;\n    } else {\n      this.dirtyPuts += 1;\n    }\n\n    if (handler.isBlockable()) {\n      if (this.puts.length >= MAX_QUEUE_SIZE) {\n        throw new Error(`No more than ${MAX_QUEUE_SIZE} pending puts are allowed on a single channel.`);\n      }\n      this.puts.unboundedUnshift(new PutBox(handler, value));\n    }\n\n    return null;\n  }\n\n  take(handler) {\n    if (!handler.isActive()) {\n      return null;\n    }\n\n    if (this.buf && this.buf.count() > 0) {\n      handler.commit();\n      // flow-ignore\n      const value = this.buf.remove();\n\n      // We need to check pending puts here, other wise they won't\n      // be able to proceed until their number reaches MAX_DIRTY\n\n      // flow-ignore\n      while (this.puts.length > 0 && !this.buf.isFull()) {\n        const putter = this.puts.pop();\n\n        // flow-ignore\n        if (putter.handler.isActive()) {\n          // flow-ignore\n          taskScheduler(putter.handler.commit(), true);\n\n          // flow-ignore\n          if (isReduced(this.xform['@@transducer/step'](this.buf, putter.value))) {\n            this.close();\n          }\n        }\n      }\n      return new Box(value);\n    }\n\n    // Either the buffer is empty, in which case there won't be any\n    // pending puts, or we don't have a buffer, in which case this loop\n    // fulfills the first of them that is active (note that we don't\n    // have to worry about transducers here since we require a buffer\n    // for that).\n    while (this.puts.length > 0) {\n      const putter = this.puts.pop();\n\n      // flow-ignore\n      if (putter.handler.isActive()) {\n        handler.commit();\n        // flow-ignore\n        taskScheduler(putter.handler.commit(), true);\n\n        // flow-ignore\n        return new Box(putter.value);\n      }\n    }\n\n    if (this.closed) {\n      handler.commit();\n      return new Box(CLOSED);\n    }\n\n    // No buffer, empty buffer, no pending puts. Queue this take now if blockable.\n    if (this.dirtyTakes > MAX_DIRTY) {\n      this.takes.cleanup(_handler => _handler.isActive());\n      this.dirtyTakes = 0;\n    } else {\n      this.dirtyTakes += 1;\n    }\n\n    if (handler.isBlockable()) {\n      if (this.takes.length >= MAX_QUEUE_SIZE) {\n        throw new Error(`No more than ${MAX_QUEUE_SIZE} pending takes are allowed on a single channel.`);\n      }\n\n      this.takes.unboundedUnshift(handler);\n    }\n\n    return null;\n  }\n\n  close() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    if (this.buf) {\n      this.xform['@@transducer/result'](this.buf);\n\n      while (this.buf.count() > 0 && this.takes.length > 0) {\n        const taker = this.takes.pop();\n\n        // flow-ignore\n        if (taker.isActive()) {\n          // flow-ignore\n          taskScheduler(taker.commit(), this.buf.remove());\n        }\n      }\n    }\n\n    flush(this.takes, taker => {\n      if (taker.isActive()) {\n        taskScheduler(taker.commit(), CLOSED);\n      }\n    });\n\n    flush(this.puts, putter => {\n      if (putter.handler.isActive()) {\n        taskScheduler(putter.handler.commit(), false);\n      }\n    });\n  }\n\n  isClosed() {\n    return this.closed;\n  }\n}\n\n// The base transformer object to use with transducers\nconst AddTransformer = {\n  '@@transducer/init': () => {\n    throw new Error('init not available');\n  },\n\n  '@@transducer/result': v => v,\n\n  '@@transducer/step': (buffer, input) => {\n    buffer.add(input);\n    return buffer;\n  }\n};\n\nfunction defaultExceptionHandler(err) {\n  console.log('error in channel transformer', err.stack); // eslint-disable-line\n  return CLOSED;\n}\n\nfunction handleEx(buf, exHandler, e) {\n  const def = (exHandler || defaultExceptionHandler)(e);\n\n  if (def !== CLOSED) {\n    buf.add(def);\n  }\n\n  return buf;\n}\n\nfunction handleException(exHandler) {\n  return xform => ({\n    '@@transducer/step': (buffer, input) => {\n      try {\n        return xform['@@transducer/step'](buffer, input);\n      } catch (e) {\n        return handleEx(buffer, exHandler, e);\n      }\n    },\n    '@@transducer/result': buffer => {\n      try {\n        return xform['@@transducer/result'](buffer);\n      } catch (e) {\n        return handleEx(buffer, exHandler, e);\n      }\n    }\n  });\n}\n\n// XXX: This is inconsistent. We should either call the reducing\n// function xform, or call the transducers xform, not both\nexport function chan(buf, xform, exHandler) {\n  let newXForm;\n\n  if (xform) {\n    if (!buf) {\n      throw new Error('Only buffered channels can use transducers');\n    }\n\n    newXForm = xform(AddTransformer);\n  } else {\n    newXForm = AddTransformer;\n  }\n\n  return new Channel(ring(32), ring(32), buf, handleException(exHandler)(newXForm));\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/dispatch.js":"import _setImmediate from 'babel-runtime/core-js/set-immediate';\nimport { RingBuffer, ring } from './buffers';\n\nconst TASK_BATCH_SIZE = 1024;\nconst tasks = ring(32);\nlet running = false;\nlet queued = false;\n\nexport function queueDispatcher() {\n  // See the implementation of setImmediate at babel-runtime/core-js/set-immediate\n  // https://github.com/zloirock/core-js/blob/e482646353b489e200a5ecccca6af5c01f0b4ef2/library/modules/_task.js\n  // Under the hood, it will use process.nextTick, MessageChannel, and fallback to setTimeout\n  if (!(queued && running)) {\n    queued = true;\n\n    _setImmediate(() => {\n      let count = 0;\n\n      running = true;\n      queued = false;\n\n      while (count < TASK_BATCH_SIZE) {\n        const task = tasks.pop();\n\n        if (task) {\n          task();\n          count += 1;\n        } else {\n          break;\n        }\n      }\n\n      running = false;\n\n      if (tasks.length > 0) {\n        queueDispatcher();\n      }\n    });\n  }\n}\n\nexport function run(func) {\n  tasks.unboundedUnshift(func);\n  queueDispatcher();\n}\n\nexport function queueDelay(func, delay) {\n  setTimeout(func, delay);\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/handlers.js":"import noop from 'lodash/noop';\nimport { Box } from './boxes';\n\nexport class FnHandler {\n\n  constructor(blockable, func) {\n    this.blockable = blockable;\n    this.func = func || noop;\n  }\n\n  isActive() {\n    // eslint-disable-line\n    return true;\n  }\n\n  isBlockable() {\n    return this.blockable;\n  }\n\n  commit() {\n    return this.func;\n  }\n}\n\nexport class AltHandler {\n\n  constructor(flag, func) {\n    this.flag = flag;\n    this.func = func;\n  }\n\n  isActive() {\n    return this.flag.value;\n  }\n\n  isBlockable() {\n    // eslint-disable-line\n    return true;\n  }\n\n  commit() {\n    this.flag.value = false;\n    return this.func;\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/instruction.js":"import { Channel } from './channels';\n\nexport class TakeInstruction {\n\n  constructor(channel) {\n    this.channel = channel;\n  }\n}\n\nexport class PutInstruction {\n\n  constructor(channel, value) {\n    this.channel = channel;\n    this.value = value;\n  }\n}\n\nexport class SleepInstruction {\n\n  constructor(msec) {\n    this.msec = msec;\n  }\n}\n\nexport class AltsInstruction {\n\n  constructor(operations, options) {\n    this.operations = operations;\n    this.options = options;\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/process.js":"import _setImmediate from 'babel-runtime/core-js/set-immediate';\nimport { doAlts } from './select';\nimport { FnHandler } from './handlers';\nimport { TakeInstruction, PutInstruction, SleepInstruction, AltsInstruction } from './instruction';\nimport { Box } from './boxes';\nimport { Channel } from './channels';\nimport { queueDelay } from './dispatch';\n\nexport const NO_VALUE = '@@process/NO_VALUE';\n\nexport function putThenCallback(channel, value, callback) {\n  const result = channel.put(value, new FnHandler(true, callback));\n\n  if (result && callback) {\n    callback(result.value);\n  }\n}\n\nexport function takeThenCallback(channel, callback) {\n  const result = channel.take(new FnHandler(true, callback));\n\n  if (result && callback) {\n    callback(result.value);\n  }\n}\n\nexport function take(channel) {\n  return new TakeInstruction(channel);\n}\n\nexport function put(channel, value) {\n  return new PutInstruction(channel, value);\n}\n\nexport function sleep(msecs) {\n  return new SleepInstruction(msecs);\n}\n\nexport function alts(operations, options) {\n  return new AltsInstruction(operations, options);\n}\n\nexport function poll(channel) {\n  if (channel.closed) {\n    return NO_VALUE;\n  }\n\n  const result = channel.take(new FnHandler(false));\n\n  return result ? result.value : NO_VALUE;\n}\n\nexport function offer(channel, value) {\n  if (channel.closed) {\n    return false;\n  }\n\n  const result = channel.put(value, new FnHandler(false));\n\n  return result instanceof Box;\n}\n\nexport class Process {\n\n  constructor(gen, onFinishFunc) {\n    this.schedule = nextState => {\n      _setImmediate(() => this.run(nextState));\n    };\n\n    this.gen = gen;\n    this.finished = false;\n    this.onFinishFunc = onFinishFunc;\n  }\n\n  run(state) {\n    if (!this.finished) {\n      // TODO: Shouldn't we (optionally) stop error propagation here (and\n      // signal the error through a channel or something)? Otherwise the\n      // uncaught exception will crash some runtimes (e.g. Node)\n      const { done, value } = this.gen.next(state);\n\n      if (done) {\n        this.finished = true;\n        this.onFinishFunc(value);\n      } else if (value instanceof TakeInstruction) {\n        takeThenCallback(value.channel, this.schedule);\n      } else if (value instanceof PutInstruction) {\n        putThenCallback(value.channel, value.value, this.schedule);\n      } else if (value instanceof SleepInstruction) {\n        queueDelay(this.schedule, value.msec);\n      } else if (value instanceof AltsInstruction) {\n        doAlts(value.operations, this.schedule, value.options);\n      } else if (value instanceof Channel) {\n        takeThenCallback(value, this.schedule);\n      } else {\n        this.schedule(value);\n      }\n    }\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/results.js":"import { Channel } from './channels';\n\nexport const DEFAULT = {\n  toString() {\n    return '[object DEFAULT]';\n  }\n};\n\nexport class AltResult {\n\n  constructor(value, channel) {\n    this.value = value;\n    this.channel = channel;\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/select.js":"import has from 'lodash/get';\nimport range from 'lodash/range';\nimport shuffle from 'lodash/shuffle';\nimport { Box } from './boxes';\nimport { Channel } from './channels';\nimport { AltHandler } from './handlers';\nimport { AltResult, DEFAULT } from './results';\n\n// TODO: Accept a priority function or something\nexport function doAlts( // eslint-disable-line\noperations, callback, options) {\n  if (operations.length === 0) {\n    throw new Error('Empty alt list');\n  }\n\n  const flag = new Box(true);\n  const indexes = shuffle(range(operations.length));\n  const hasPriority = !!(options && options.priority);\n  let result;\n\n  for (let i = 0; i < operations.length; i += 1) {\n    const operation = operations[hasPriority ? i : indexes[i]];\n    let ch;\n\n    if (operation instanceof Channel) {\n      ch = operation;\n      result = ch.take(new AltHandler(flag, value => callback(new AltResult(value, ch))));\n    } else {\n      ch = operation[0];\n      result = ch.put(operation[1], new AltHandler(flag, value => callback(new AltResult(value, ch))));\n    }\n\n    if (result) {\n      callback(new AltResult(result.value, ch));\n      break;\n    }\n  }\n\n  if (!result && has(options, 'default') && flag.value) {\n    flag.value = false;\n    callback(new AltResult(options.default, DEFAULT));\n  }\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/timers.js":"import { queueDelay } from './dispatch';\nimport { chan, Channel } from './channels';\n\nexport function timeout(msecs) {\n  // eslint-disable-line\n  const ch = chan();\n\n  queueDelay(() => ch.close(), msecs);\n\n  return ch;\n}","/home/travis/build/npmtest/node-npmtest-js-csp/node_modules/js-csp/es/impl/utils.js":"import { run } from './dispatch';\n\n\nexport const taskScheduler = (func, value) => {\n  run(() => func(value));\n};\n\nexport const isReduced = v => v && v['@@transducer/reduced'];\n\nexport function flush(channelBuffer, callback) {\n  while (channelBuffer.length > 0) {\n    callback(channelBuffer.pop());\n  }\n}"}